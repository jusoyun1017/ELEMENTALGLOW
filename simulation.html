<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU 수채화 시뮬레이터</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard syntax */
        }

        #app {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #webgpuCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            background-color: white; /* 캔버스 기본 배경 */
        }

        #colorWheelContainer {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 50%;
            background-color: transparent;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: visible;
            cursor: default;
            z-index: 10;
        }

        #colorPalette {
            position: relative;
            border-radius: 50%;
        }

        .color-button {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid white;
            box-sizing: border-box;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            transform: rotate(var(--initial-rotation-compensate, 0deg));
            z-index: 1;
        }

        .color-button:hover {
            transform: scale(1.1) rotate(var(--initial-rotation-compensate, 0deg));
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.8), 0 0 15px rgba(0, 0, 0, 0.6);
            z-index: 2;
        }

        #colorPointer {
            position: fixed;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #00bcd4;
            border: 4px solid white;
            box-shadow: 0 0 0 2px #00bcd4, 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
            z-index: 9999;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        #clearButton {
            padding: 8px 15px;
            background-color: #000000;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            width: 100%;
            box-sizing: border-box;
        }

        #clearButton:hover {
            background-color: #333333;
        }

        #hoverTextDisplay {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            padding: 5px 10px;
            background-color: transparent;
            color: black;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <canvas id="webgpuCanvas"></canvas>
        <div id="controls">
            <button id="clearButton">캔버스 초기화</button>
        </div>
    </div>
    
    <div id="colorWheelContainer">
        <div id="colorPalette"></div>
        <div id="hoverTextDisplay"></div>
    </div>
    <div id="colorPointer"></div> 

    <script type="module">
        if (!navigator.gpu) {
            alert("WebGPU를 지원하지 않는 브라우저입니다. 최신 Chrome Canary 또는 Edge를 사용해 보세요.");
            document.body.innerHTML = "<h1>WebGPU를 지원하지 않습니다.</h1>";
        }

        const SIM_SIZE = 512; // 시뮬레이션 그리드 해상도 (512x512)
        const WORKGROUP_SIZE = 8; // 컴퓨트 셰이더 워크그룹 크기 (SIM_SIZE는 WORKGROUP_SIZE의 배수여야 함)

        // ===== WGSL Shaders =====

        // 시뮬레이션 컴퓨트 셰이더 (반응-확산)
        const simulationShaderWGSL = `
            struct SimParams {
                diffusionRateC: f32; // 물감 확산 계수
                diffusionRateW: f32; // 물 확산 계수
                timeStep: f32;       // 시간 간격
                feedRate: f32;       // 물감 주입/소모 비율
                killRate: f32;       // 물 소모 비율
            };

            @group(0) @binding(0) var<uniform> params: SimParams;
            @group(0) @binding(1) var inputSim: texture_2d<f32>; // 텍스처는 픽셀당 하나의 32비트 부동소수점 값
            @group(0) @binding(2) var outputSim: texture_storage_2d<rgba32float, write>; // 출력은 RGBA32F

            // 이웃 픽셀 샘플링을 위한 샘플러 (컴퓨트 셰이더에서는 직접 샘플링 불가, 텍스처 로드로 대체)
            // @group(0) @binding(3) var simSampler: sampler; // 컴퓨트 셰이더에서 샘플러 사용 불가 (texture_2d 사용 시 텍스처는 읽기 전용)

            fn get_pixel(coord: vec2<i32>) -> vec2<f32> {
                // texture_2d는 기본적으로 RGBA 형식이므로 .xy (C, W)를 가져옴
                return textureLoad(inputSim, coord).xy;
            }

            @compute @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE}, 1)
            fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                let coord = vec2<i32>(global_id.xy);
                let sim_size = vec2<i32>(textureDimensions(inputSim));

                // 경계 조건 처리 (안전하게 인덱싱)
                if (coord.x < 0 || coord.x >= sim_size.x || coord.y < 0 || coord.y >= sim_size.y) {
                    return;
                }

                let center = get_pixel(coord);
                var laplacianC = 0.0;
                var laplacianW = 0.0;
                
                // 4방향 이웃 (Neumann 경계 조건 - 가장자리는 자신의 값으로 간주)
                let neighbors = array<vec2<i32>, 4>(
                    vec2<i32>(0, 1), vec2<i32>(0, -1), 
                    vec2<i32>(1, 0), vec2<i32>(-1, 0)
                );

                for (var i = 0; i < 4; i++) {
                    let neighborCoord = coord + neighbors[i];
                    let neighbor = get_pixel(neighborCoord);
                    laplacianC += neighbor.x;
                    laplacianW += neighbor.y;
                }

                laplacianC -= 4.0 * center.x;
                laplacianW -= 4.0 * center.y;

                // 반응-확산 방정식 (Gray-Scott 모델 기반, 수채화 느낌으로 변형)
                let reaction = center.x * center.y * center.y;
                let newC = center.x + params.timeStep * (params.diffusionRateC * laplacianC - reaction + params.feedRate);
                let newW = center.y + params.timeStep * (params.diffusionRateW * laplacianW + reaction - (params.feedRate + params.killRate));
                
                // 값 클램프 (0.0 ~ 1.0 사이 유지)
                let finalC = clamp(newC, 0.0, 1.0);
                let finalW = clamp(newW, 0.0, 1.0);

                textureStore(outputSim, coord, vec4<f32>(finalC, finalW, 0.0, 1.0));
            }
        `;

        // 마우스 입력 컴퓨트 셰이더 (클릭 위치에 물감 주입)
        const inputShaderWGSL = `
            struct InputParams {
                inputX: f32;
                inputY: f32;
                radius: f32;
                colorR: f32;
                colorG: f32;
                colorB: f32;
            };

            @group(0) @binding(0) var<uniform> params: InputParams;
            @group(0) @binding(1) var inputSim: texture_2d<f32>;
            @group(0) @binding(2) var outputSim: texture_storage_2d<rgba32float, write>;

            @compute @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE}, 1)
            fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                let coord = vec2<i32>(global_id.xy);
                let sim_size = vec2<f32>(textureDimensions(inputSim));

                let center_x = params.inputX * sim_size.x;
                let center_y = params.inputY * sim_size.y;
                let brush_radius_px = params.radius * sim_size.x;

                let dist = distance(vec2<f32>(coord), vec2<f32>(center_x, center_y));

                let current_values = textureLoad(inputSim, coord).xy; // 현재 C, W 값

                var finalC = current_values.x;
                var finalW = current_values.y;

                if (dist < brush_radius_px) {
                    // 브러시 내부에서 물감 농도 C와 습도 W를 주입
                    let strength = 1.0 - smoothstep(0.0, brush_radius_px, dist); // 중심부 강하게

                    // 기존 물감 위에 새 물감을 덧칠하고, 물(W)도 주입
                    // 새로운 C = (이전 C * (1-strength)) + (새로운 물감 * strength)
                    // 새로운 W = (이전 W * (1-strength)) + (새로운 물 * strength * 0.5)
                    // 단순화: 그냥 강한 값으로 덮어씀 (C는 RGB값 사용, W는 고정값)
                    finalC = clamp(current_values.x + strength * 0.2, 0.0, 1.0); // 물감 농도 증가
                    finalW = clamp(current_values.y + strength * 0.5, 0.0, 1.0); // 물 추가
                }

                textureStore(outputSim, coord, vec4<f32>(finalC, finalW, 0.0, 1.0));
            }
        `;

        // 최종 렌더링 셰이더
        const renderShaderWGSL = `
            @group(0) @binding(0) var simTexture: texture_2d<f32>; // 시뮬레이션 결과 텍스처
            @group(0) @binding(1) var simSampler: sampler;         // 샘플러
            @group(0) @binding(2) var<uniform> currentColor: vec4<f32>; // 선택된 RGB 색상

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) texCoord: vec2<f32>,
            };

            @vertex
            fn vertex_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                var output: VertexOutput;
                let pos = array<vec2<f32>, 6>(
                    vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), 
                    vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
                );
                let tex = array<vec2<f32>, 6>(
                    vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(0.0, 0.0), 
                    vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(1.0, 0.0)
                );
                
                output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                output.texCoord = tex[vertexIndex];
                return output;
            }

            @fragment
            fn fragment_main(input: VertexOutput) -> @location(0) vec4<f32> {
                let simValue = textureSample(simTexture, simSampler, input.texCoord).xy;
                let C = simValue.x; // 물감 농도
                let W = simValue.y; // 물/습도

                // 물감 농도 C를 사용하여 색상을 조정
                // C가 0이면 흰색, C가 1에 가까우면 선택된 색상으로
                // W(습도)는 번짐의 투명도를 조절하는 데 사용될 수 있지만, 여기서는 C에 집중.
                
                // 수채화처럼 옅게 보이지만 농도에 따라 진해지게
                let finalR = mix(1.0, currentColor.r, C * 0.7); // 0.7은 색상의 최대 진하기 (조절 가능)
                let finalG = mix(1.0, currentColor.g, C * 0.7);
                let finalB = mix(1.0, currentColor.b, C * 0.7);

                // 물감 가장자리가 살짝 어두워지는 효과 (안료 응집)
                let edgeEffect = smoothstep(0.0, 0.2, C) * (1.0 - smoothstep(0.8, 1.0, C));
                let darkEdge = vec3<f32>(0.0, 0.0, 0.0) * edgeEffect * 0.1; // 가장자리에 어두운 색상 추가
                
                return vec4<f32>(vec3(finalR, finalG, finalB) + darkEdge, 1.0);
            }
        `;

        // ===== Utility Functions =====

        // 헥사 코드를 RGBA 포맷으로 변환
        function hexToRgbaArray(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255.0;
            const g = parseInt(hex.slice(3, 5), 16) / 255.0;
            const b = parseInt(hex.slice(5, 7), 16) / 255.0;
            return [r, g, b, 1.0];
        }

        // ===== WebGPU Initialization =====
        async function initWebGPU() {
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                alert("WebGPU 어댑터를 찾을 수 없습니다.");
                return;
            }
            const device = await adapter.requestDevice();
            
            const canvas = document.getElementById('webgpuCanvas');
            const context = canvas.getContext('webgpu');

            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
                alphaMode: 'opaque', // 캔버스 배경이 흰색이므로 opaque (불투명)
            });

            // ===== Simulation Textures (Double Buffering) =====
            const simTextureFormat = 'rgba32float'; // C, W, (padding), (padding)
            let inputSimTexture = device.createTexture({
                size: [SIM_SIZE, SIM_SIZE],
                format: simTextureFormat,
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
            });
            let outputSimTexture = device.createTexture({
                size: [SIM_SIZE, SIM_SIZE],
                format: simTextureFormat,
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING,
            });

            // 텍스처 뷰 (바인드 그룹에 사용)
            let inputSimView = inputSimTexture.createView();
            let outputSimView = outputSimTexture.createView();

            // 시뮬레이션 초기화 (모든 픽셀을 W=1.0, C=0.0으로)
            const initialData = new Float32Array(SIM_SIZE * SIM_SIZE * 4); // RGBA
            for (let i = 0; i < SIM_SIZE * SIM_SIZE; i++) {
                initialData[i * 4 + 0] = 0.0; // C (물감 농도)
                initialData[i * 4 + 1] = 1.0; // W (물/습도)
                initialData[i * 4 + 2] = 0.0; // R
                initialData[i * 4 + 3] = 1.0; // G
            }
            device.queue.writeTexture(
                { texture: inputSimTexture },
                initialData,
                { bytesPerRow: SIM_SIZE * 4 * 4 }, // 4 bytes per float, 4 channels
                { width: SIM_SIZE, height: SIM_SIZE }
            );


            // ===== Uniform Buffers =====
            // Simulation Params Uniform Buffer
            const simParamsBufferSize = (5 * Float32Array.BYTES_PER_ELEMENT); // dc, dw, dt, feed, kill
            const simParamsBuffer = device.createBuffer({
                size: simParamsBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const simParamsData = new Float32Array([
                0.015,  // diffusionRateC (물감 확산 속도, 낮을수록 뭉침)
                0.005,  // diffusionRateW (물 확산 속도, 높을수록 번짐)
                1.0,    // timeStep
                0.02,   // feedRate (새 물감 주입 속도)
                0.05    // killRate (물 증발/소모 속도)
            ]);
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData);

            // Input Params Uniform Buffer (마우스 입력)
            const inputParamsBufferSize = (6 * Float32Array.BYTES_PER_ELEMENT); // x, y, radius, r, g, b
            const inputParamsBuffer = device.createBuffer({
                size: inputParamsBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const inputParamsData = new Float32Array([0, 0, 0.05, 1, 0, 0]); // 초기값: x, y, radius, r, g, b
            device.queue.writeBuffer(inputParamsBuffer, 0, inputParamsData);

            // Current Color Uniform Buffer (렌더링)
            const currentColorBufferSize = (4 * Float32Array.BYTES_PER_ELEMENT); // r, g, b, a
            const currentColorBuffer = device.createBuffer({
                size: currentColorBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const currentColorData = hexToRgbaArray('#9E1111'); // 초기 색상
            device.queue.writeBuffer(currentColorBuffer, 0, currentColorData);


            // ===== Compute Pipelines =====
            // Simulation Compute Pipeline
            const simPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: device.createShaderModule({ code: simulationShaderWGSL }),
                    entryPoint: 'main',
                },
            });

            // Input Compute Pipeline (마우스 드로잉)
            const inputPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: device.createShaderModule({ code: inputShaderWGSL }),
                    entryPoint: 'main',
                },
            });

            // ===== Render Pipeline =====
            // Full-screen Quad Vertex Buffer (for rendering)
            const vertices = new Float32Array([
                -1.0, -1.0,  0.0, 1.0, // pos, texCoord
                 1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  0.0, 0.0,

                -1.0,  1.0,  0.0, 0.0,
                 1.0, -1.0,  1.0, 1.0,
                 1.0,  1.0,  1.0, 0.0,
            ]);
            const vertexBuffer = device.createBuffer({
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true,
            });
            new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
            vertexBuffer.unmap();

            // Sampler for Render Pipeline
            const simSampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
            });

            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: device.createShaderModule({ code: renderShaderWGSL }),
                    entryPoint: 'vertex_main',
                    buffers: [{
                        arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT, // 4 floats (x,y,u,v)
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: 'float32x2' }, // Position
                            { shaderLocation: 1, offset: 2 * Float32Array.BYTES_PER_ELEMENT, format: 'float32x2' }, // TexCoord
                        ],
                    }],
                },
                fragment: {
                    module: device.createShaderModule({ code: renderShaderWGSL }),
                    entryPoint: 'fragment_main',
                    targets: [{ format: presentationFormat }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });

            // ===== Bind Groups =====
            // Simulation Bind Group (updates every frame for double buffering)
            let simBindGroup = device.createBindGroup({
                layout: simPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: simParamsBuffer } },
                    { binding: 1, resource: inputSimView },
                    { binding: 2, resource: outputSimView },
                ],
            });

            // Input Bind Group (updates for mouse input)
            let inputBindGroup = device.createBindGroup({
                layout: inputPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: inputParamsBuffer } },
                    { binding: 1, resource: inputSimView },
                    { binding: 2, resource: outputSimView },
                ],
            });

            // Render Bind Group (reads final simulation texture)
            let renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: inputSimView },
                    { binding: 1, resource: simSampler },
                    { binding: 2, resource: { buffer: currentColorBuffer } },
                ],
            });
            

            // ===== Animation Loop =====
            let isDrawing = false;
            let currentBrushRadius = 0.05; // 캔버스 너비 대비 비율 (초기값)
            const MAX_BRUSH_RADIUS = 0.15; // 최대 브러시 크기 (캔버스 너비 대비)
            const BRUSH_GROW_SPEED = 0.0002; // 마우스 누르는 동안 브러시 커지는 속도

            function frame() {
                // Resize canvas if needed
                if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    // WebGPU context reconfigure if size changes (optional for fixed size sim)
                    context.configure({
                        device,
                        format: presentationFormat,
                        alphaMode: 'opaque',
                        size: [canvas.width, canvas.height]
                    });
                }

                // 1. Compute Simulation
                const commandEncoder = device.createCommandEncoder();
                const computePass = commandEncoder.beginComputePass();

                // Swap textures for simulation
                simBindGroup = device.createBindGroup({
                    layout: simPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: simParamsBuffer } },
                        { binding: 1, resource: inputSimView },
                        { binding: 2, resource: outputSimView },
                    ],
                });

                computePass.setPipeline(simPipeline);
                computePass.setBindGroup(0, simBindGroup);
                computePass.dispatchWorkgroups(SIM_SIZE / WORKGROUP_SIZE, SIM_SIZE / WORKGROUP_SIZE);
                computePass.end();

                // 2. Swap input/output textures
                [inputSimTexture, outputSimTexture] = [outputSimTexture, inputSimTexture];
                inputSimView = inputSimTexture.createView();
                outputSimView = outputSimTexture.createView();

                // 3. Render final simulation texture to canvas
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },
                        storeOp: 'store',
                    }],
                });

                // Update render bind group with new inputSimView (which now holds latest sim state)
                renderBindGroup = device.createBindGroup({
                    layout: renderPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: inputSimView }, // Render latest sim state
                        { binding: 1, resource: simSampler },
                        { binding: 2, resource: { buffer: currentColorBuffer } },
                    ],
                });

                renderPass.setPipeline(renderPipeline);
                renderPass.setBindGroup(0, renderBindGroup);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.draw(6);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                requestAnimationFrame(frame);
            }

            // ===== Event Listeners =====
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                currentBrushRadius = 0.05; // 클릭 시 초기 브러시 크기
                handleMouseMove(e); // 첫 클릭 위치에 바로 그리기
            });

            document.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            canvas.addEventListener('mousemove', handleMouseMove);

            function handleMouseMove(e) {
                if (!isDrawing) return;

                // 브러시 크기 성장
                currentBrushRadius = Math.min(currentBrushRadius + BRUSH_GROW_SPEED, MAX_BRUSH_RADIUS);

                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width;  // 0.0 to 1.0
                const mouseY = (e.clientY - rect.top) / rect.height; // 0.0 to 1.0

                // Update Input Params Buffer
                const inputParamsUpdatedData = new Float32Array([
                    mouseX, mouseY, currentBrushRadius, 
                    currentColorData[0], currentColorData[1], currentColorData[2]
                ]);
                device.queue.writeBuffer(inputParamsBuffer, 0, inputParamsUpdatedData);

                // Compute Input (draw on current inputSimTexture)
                const inputEncoder = device.createCommandEncoder();
                const inputPass = inputEncoder.beginComputePass();

                // Swap input/output textures for the input pass
                inputBindGroup = device.createBindGroup({
                    layout: inputPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: inputParamsBuffer } },
                        { binding: 1, resource: inputSimView },
                        { binding: 2, resource: outputSimView },
                    ],
                });

                inputPass.setPipeline(inputPipeline);
                inputPass.setBindGroup(0, inputBindGroup);
                inputPass.dispatchWorkgroups(SIM_SIZE / WORKGROUP_SIZE, SIM_SIZE / WORKGROUP_SIZE);
                inputPass.end();
                device.queue.submit([inputEncoder.finish()]);

                // Swap after input pass to make the newly drawn input the next 'input' for simulation
                [inputSimTexture, outputSimTexture] = [outputSimTexture, inputSimTexture];
                inputSimView = inputSimTexture.createView();
                outputSimView = outputSimTexture.createView();
            }


            // ===== UI Elements (Color Wheel, Clear Button) =====
            const colorWheelContainer = document.getElementById('colorWheelContainer');
            const colorPointer = document.getElementById('colorPointer');
            const colorPalette = document.getElementById('colorPalette');
            const hoverTextDisplay = document.getElementById('hoverTextDisplay'); 
            const clearButton = document.getElementById('clearButton');

            let paletteRotationAngle = 0;
            const NUM_BUTTONS = 18;
            const BUTTON_RADIUS = 120; 
            const BUTTON_SIZE = 60; 
            const COLORS = [
                '#9E1111', '#CD0000', '#E53935', '#FF7043', '#FFB74D', '#FDD835',
                '#8BC34A', '#4CAF50', '#009688', '#00BCD4', '#03A9F4', '#1976D2',
                '#5C6BC0', '#7E57C2', '#AB47BC', '#EC407A', '#FF8A80', '#FFFFFF'
            ];

            // Create circular color buttons
            function createColorPalette() {
                colorPalette.innerHTML = '';
                for (let i = 0; i < NUM_BUTTONS; i++) {
                    const angle = (i / NUM_BUTTONS) * Math.PI * 2 + paletteRotationAngle;
                    const btn = document.createElement('div');
                    btn.className = 'color-button';
                    // place buttons around a circle using transforms
                    const x = Math.cos(angle) * BUTTON_RADIUS;
                    const y = Math.sin(angle) * BUTTON_RADIUS;
                    btn.style.left = `calc(50% + ${x}px - ${BUTTON_SIZE / 2}px)`;
                    btn.style.top = `calc(50% + ${y}px - ${BUTTON_SIZE / 2}px)`;
                    const color = COLORS[i % COLORS.length];
                    btn.style.background = color;
                    // Keep the button visually upright when palette rotates
                    btn.style.setProperty('--initial-rotation-compensate', `${-paletteRotationAngle}rad`);

                    // Hover tooltip
                    btn.addEventListener('mouseenter', () => {
                        hoverTextDisplay.style.opacity = '1';
                        hoverTextDisplay.textContent = color;
                        setTimeout(() => { hoverTextDisplay.style.opacity = '0'; }, 900);
                    });

                    // Click -> select color
                    btn.addEventListener('click', () => {
                        currentColorData = hexToRgbaArray(color);
                        device.queue.writeBuffer(currentColorBuffer, 0, new Float32Array(currentColorData));
                        colorPointer.style.backgroundColor = color;
                    });

                    colorPalette.appendChild(btn);
                }
            }

            // Pointer follows the mouse and shows currently selected color
            document.addEventListener('mousemove', (e) => {
                colorPointer.style.left = `${e.clientX}px`;
                colorPointer.style.top = `${e.clientY}px`;
            });

            // Clear simulation — reinitialize both simulation textures
            clearButton.addEventListener('click', () => {
                // Reset textures to initial state (C=0.0, W=1.0)
                device.queue.writeTexture(
                    { texture: inputSimTexture },
                    initialData,
                    { bytesPerRow: SIM_SIZE * 4 * 4 },
                    { width: SIM_SIZE, height: SIM_SIZE }
                );
                device.queue.writeTexture(
                    { texture: outputSimTexture },
                    initialData,
                    { bytesPerRow: SIM_SIZE * 4 * 4 },
                    { width: SIM_SIZE, height: SIM_SIZE }
                );
            });

            // Initialize UI and start simulation loop
            createColorPalette();

            // Start the frame loop
            requestAnimationFrame(frame);

        }

        // Call init and report any errors gracefully
        initWebGPU().catch(err => {
            console.error('WebGPU 초기화 실패:', err);
            alert('WebGPU 초기화에 실패했습니다. 콘솔을 확인하세요.');
        });
    </script>
</body>
</html>