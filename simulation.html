<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELEMETAL GLOW</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: #f8f8f8;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none; 
            font-family: sans-serif;
        }

        /* Application wrapper fills the viewport */
        #app {
            /* ensure the app always fills the viewport and is pinned to the top-left
               use fixed rather than relative so it isn't affected by body centering */
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background-color: white;
            box-shadow: none;
            overflow: hidden;
        }

        #webgpuCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 1;
        }

        /* 2D watercolor canvas (overlay) */
        #watercolorCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 2; /* below wet layer */
        }

        /* wet layer canvas: dynamic wet pigment that dries over time */
        #watercolorWetCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
            position: absolute;
            left: 0;
            top: 0;
            z-index: 3; /* above watercolorCanvas */
            pointer-events: none; /* we use watercolorCanvas for input events */
        }

        /* --- 색상 선택 버튼 컨테이너 --- */
        #colorWheelContainer {
            position: absolute; 
            top: 50%;
            transform: translateY(-50%); 
            
            border-radius: 50%;
            background-color: transparent; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: visible; 
            cursor: default; 
            z-index: 10; 
        }

        /* --- 18개 버튼을 담을 원형 컨테이너 (회전 대상) --- */
        #colorPalette {
            position: relative;
            border-radius: 50%;
        }

        /* --- 개별 색상 버튼 스타일 --- */
        .color-button {
            position: absolute;
            width: 60px; 
            height: 60px;
            border-radius: 50%;
            border: 2px solid white;
            box-sizing: border-box;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; 
            transform: rotate(var(--initial-rotation-compensate, 0deg));
            z-index: 1; 
        }

        /* 마우스 오버 시 크기 확대 효과 재추가 */
        .color-button:hover {
            transform: scale(1.1) rotate(var(--initial-rotation-compensate, 0deg)); 
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.8), 0 0 15px rgba(0, 0, 0, 0.6);
            z-index: 2; 
        }

        /* --- 색상 포인터 --- */
        #colorPointer {
            position: fixed; 
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: #00bcd4;
            border: 4px solid white;
            box-shadow: 0 0 0 2px #00bcd4, 0 4px 10px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s; 
            z-index: 9999; 
            transform: translate(-50%, -50%); 
            pointer-events: none; 
        }
        
        /* --- 컨트롤 패널 스타일 (캔버스 초기화) --- */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px; 
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            font-family: sans-serif;
        }
        
        #controls button {
            padding: 8px 15px;
            background-color: #000000; 
            color: white; 
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            width: 100%;
            box-sizing: border-box;
        }

        /* advanced control UI (sliders) */
        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .control-row label {
            width: 110px;
            font-size: 13px;
            color: #333;
            pointer-events: none;
        }

        .control-row input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 160px;
            height: 6px;
            background: #ddd;
            border-radius: 6px;
            outline: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #3a86ff;
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            cursor: pointer;
        }

        .controls-title {
            font-weight: 700;
            margin-bottom: 6px;
            font-size: 13px;
        }

        /* hover inverts background/text for better feedback */
        #controls button:hover {
            background-color: #ffffff;
            color: #000000;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.08) inset;
        }

        /* --- 호버 텍스트 디스플레이 스타일 --- */
        #hoverTextDisplay {
            position: absolute;
            top: 50%;
            left: 10px; 
            transform: translateY(-50%);
            padding: 5px 10px;
            background-color: transparent; 
            color: #fff; 
            border-radius: 4px;
            font-family: sans-serif;
            font-size: 18px; 
            font-weight: bold;
            pointer-events: auto; /* allow clicking controls */
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            box-shadow: none; 
        }

        /* Mobile: place palette on top, centered and easier to tap */
        @media (max-width: 720px) {
            #colorWheelContainer {
                left: 50% !important;
                top: 12px !important;
                transform: translateX(-50%) !important;
                z-index: 50;
            }

            #colorPalette {
                transform: translateY(0) !important;
            }

            /* make pointer slightly smaller on touch devices */
            #colorPointer { width: 34px; height: 34px; }
        }
    </style>
</head>
<body>
    <div id="app">
        <canvas id="webgpuCanvas"></canvas>
        <!-- 2D overlay canvas for watercolor drawing (matches simulation2.html behavior) -->
        <canvas id="watercolorCanvas"></canvas>
        <canvas id="watercolorWetCanvas"></canvas>
        <div id="controls">
            <div style="display:flex; gap:8px; align-items:center;">
                <button id="clearButton">캔버스 초기화</button>
            </div>
            <div style="margin-top:8px;">
                <button id="homeButton" title="메인으로" aria-label="메인으로">메인으로</button>
            </div>

            <!-- advanced settings removed; drawing settings are fixed to the requested preset -->
            <!-- share button removed -->
            <!-- GIF feature removed -->
        </div>
        <div id="colorWheelContainer">
            <div id="colorPalette"></div>
            <div id="hoverTextDisplay"></div>
        </div>
        <div id="colorPointer"></div>
    </div>

    <script type="module">
        if (!navigator.gpu) {
            alert("WebGPU를 지원하지 않는 브라우저입니다. 최신 Chrome Canary 또는 Edge를 사용해 보세요.");
            document.body.innerHTML = "<h1>WebGPU를 지원하지 않습니다.</h1>";
        }

        const SIM_SIZE = 512; // 시뮬레이션 그리드 해상도 (512x512)
        const WORKGROUP_SIZE = 8; // 컴퓨트 셰이더 워크그룹 크기 (SIM_SIZE는 WORKGROUP_SIZE의 배수여야 함)

        // ===== WGSL Shaders =====

        // --- Shared globals so UI works even if WebGPU init fails ---
        // color list (keeps same order / colors as previously used in this file)
        const COLORS = [
            '#9E1111', '#CD0000', '#E25600', '#C8753A', '#E5B20A', '#9CA663',
            '#7E873A', '#28AF41', '#00DE6F', '#009D6B', '#649C99', '#00C9D0',
            '#1389B4', '#0A77BA', '#3D6798', '#B39BBE', '#8C5368', '#7B2626'
        ];

        // globals for optional GPU integration (assigned when initWebGPU succeeds)
        let deviceGlobal = null;
        let currentColorBufferGlobal = null;
        let inputParamsBufferGlobal = null;
        let inputSimTextureGlobal = null;
        let outputSimTextureGlobal = null;
        let initialDataGlobal = null;

        // No-op placeholder: replaced by initWebGPU when GPU input function becomes available
        window.performGpuInput = function(e) { /* will be assigned later */ };

        // --- Top-level 2D UI + drawing initialization (runs regardless of WebGPU) ---
        (function init2DUI() {
            // Create overlay canvas and palette handlers
            // Note: DOM elements exist in the HTML; just wire behavior here so it works even if GPU fails
            const watercolorCanvas = document.getElementById('watercolorCanvas');
            const wcCtx = watercolorCanvas?.getContext ? watercolorCanvas.getContext('2d') : null;
            if (wcCtx) wcCtx.imageSmoothingEnabled = true;
            // wet layer canvas: holds transient wet pigment that dries into the dry layer
            const watercolorWetCanvas = document.getElementById('watercolorWetCanvas');
            const wetCtx = watercolorWetCanvas?.getContext ? watercolorWetCanvas.getContext('2d') : null;
            if (wetCtx) wetCtx.imageSmoothingEnabled = true;
            const colorWheelContainer = document.getElementById('colorWheelContainer');
            const colorPointer = document.getElementById('colorPointer');
            const colorPalette = document.getElementById('colorPalette');
            const hoverTextDisplay = document.getElementById('hoverTextDisplay');
            const clearButton = document.getElementById('clearButton');

            if (!watercolorCanvas || !wcCtx || !colorPalette) return; // nothing to wire

            // base brush radius in CSS pixels — user requested to halve brush size
            // slightly smaller default brush for a cleaner single-stroke feel
            let baseRadius = 72; // tuned down a bit from 90
            let hasMovedSinceDown = false; // track whether pointer moved after down
            let currentDrawColor = COLORS[0] || '#9E1111';
            // expose for GPU input to read latest selected color
            window.currentDrawColorGlobal = currentDrawColor;
            let rotationAngle = 0; // degrees, for wheel rotate behavior
            let isDrawingLocal = false;
            let spreadStartTime = 0;
            let lastMoveTime = 0;
            const THROTTLE_TIME = 12; // lower throttle for more responsive strokes
            // faster spread to simulate slippery / watery paint
            const ANIMATION_DURATION = 350; // decrease from 1000 -> faster spread
            const MAX_SPREAD_FACTOR = 2.6; // larger max spread when paint has more water
            let lastPointerX = 0, lastPointerY = 0;

            // Simulation configuration (bound to UI sliders below)
            // Fixed simulation configuration (locked — advanced UI removed)
            const simConfig = {
                brushSize: 90,
                // how strongly paint follows pointer motion (0..1)
                flowStrength: 0.8,
                spreadFactor: 2.6,
                spreadDuration: ANIMATION_DURATION,
                granulation: 0.8,
                // lower mixing strength to keep strokes luminous when layered
                // reduced further so colors don't become muddy when layered
                mixingStrength: 0.42,
                dryingSpeed: 1.0,
                paperStrength: 0.28,
                detailed: true,
                minOpacity: 0.12,
                maxOpacity: 0.85,
                ephemeral: false,
                // watercolor-specific options inspired by watercolor simulation techniques
                wetOnWet: true,             // whether layers blend like wet-on-wet
                backrunStrength: 0.14,      // strength of backrun/edge bleeds
                pigmentSeparation: 0.06,    // color channel separation (chromatography-like)
                washLayers: 2,              // number of quick wash passes to layer
                bleedIntensity: 0.28,       // how strongly surrounding wash spreads
                edgeDarken: 0.22            // extra darkening around edges for aggregation
            };

            function hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            function resizeOverlay() {
                // Support high-DPI displays so drawing coordinates match client coordinates
                const ratio = window.devicePixelRatio || 1;
                const w = Math.floor(watercolorCanvas.clientWidth * ratio);
                const h = Math.floor(watercolorCanvas.clientHeight * ratio);
                watercolorCanvas.width = w;
                watercolorCanvas.height = h;
                if (watercolorWetCanvas) {
                    // keep wet canvas in sync so coordinates match
                    watercolorWetCanvas.width = w;
                    watercolorWetCanvas.height = h;
                    wetCtx.setTransform(ratio, 0, 0, ratio, 0, 0);
                }
                wcCtx.setTransform(ratio, 0, 0, ratio, 0, 0); // normalize CSS px -> canvas px
                wcCtx.clearRect(0, 0, watercolorCanvas.clientWidth, watercolorCanvas.clientHeight);
                wcCtx.fillStyle = 'white';
                wcCtx.fillRect(0, 0, watercolorCanvas.clientWidth, watercolorCanvas.clientHeight);

                // draw subtle paper texture layer behind the strokes
                // uses simConfig.paperStrength
                wcCtx.globalAlpha = simConfig.paperStrength;
                drawPaperTexture();
                wcCtx.globalAlpha = 1.0;


            // Create / draw subtle paper texture onto overlay (cached via offscreen canvas)
            let _paperPatternCanvas = null;
            function generatePaperPattern(width, height) {
                const ratio = window.devicePixelRatio || 1;
                const pw = Math.max(128, Math.ceil(width * ratio));
                const ph = Math.max(128, Math.ceil(height * ratio));
                const oc = document.createElement('canvas');
                oc.width = pw; oc.height = ph;
                const octx = oc.getContext('2d');

                // base light paper grain
                octx.fillStyle = '#ffffff';
                octx.fillRect(0, 0, pw, ph);

                // stronger speckle noise for visible paper granulation
                const img = octx.createImageData(pw, ph);
                for (let i = 0; i < img.data.length; i += 4) {
                    // biased toward lighter specks with occasional darker spots
                    const base = 225 + Math.floor(Math.random() * 30);
                    const darkChance = Math.random() < 0.02;
                    const v = darkChance ? (200 + Math.floor(Math.random() * 40)) : base;
                    img.data[i] = v; img.data[i+1] = v; img.data[i+2] = v; img.data[i+3] = darkChance ? 18 : 10;
                }
                octx.putImageData(img, 0, 0);

                // subtle paper fibers (long thin strokes)
                octx.globalAlpha = 0.08;
                for (let i = 0; i < 240; i++) {
                    octx.beginPath();
                    const x1 = Math.random() * pw;
                    const y1 = Math.random() * ph;
                    const len = 20 + Math.random() * 120;
                    const ang = (Math.random() - 0.5) * 0.6;
                    const x2 = x1 + Math.cos(ang) * len;
                    const y2 = y1 + Math.sin(ang) * len;
                    octx.strokeStyle = `rgba(${210 + Math.floor(Math.random()*30)}, ${210 + Math.floor(Math.random()*30)}, ${210 + Math.floor(Math.random()*30)}, 1)`;
                    octx.lineWidth = 0.8 + Math.random() * 2.2;
                    octx.moveTo(x1, y1);
                    octx.lineTo(x2, y2);
                    octx.stroke();
                }

                // occasional soft watermarks / stains
                for (let i = 0; i < 8; i++) {
                    const gx = Math.random() * pw;
                    const gy = Math.random() * ph;
                    const gr = 30 + Math.random() * 140;
                    const gg = octx.createRadialGradient(gx, gy, gr * 0.2, gx, gy, gr);
                    const v = 230 - Math.floor(Math.random() * 40);
                    gg.addColorStop(0, `rgba(${v},${v},${v},${0.06 + Math.random() * 0.08})`);
                    gg.addColorStop(1, 'rgba(255,255,255,0)');
                    octx.fillStyle = gg;
                    octx.beginPath();
                    octx.arc(gx, gy, gr, 0, Math.PI * 2);
                    octx.fill();
                }

                return oc;
            }

            // wet-layer animation removed: we now render watercolor effects directly
            // onto the dry canvas (`wcCtx`) immediately (no queued wet animation).
            // This simplifies the pipeline and ensures what the user draws is what
            // ends up on the dry canvas without waiting for asynchronous drying.

            function drawPaperTexture() {
                try {
                    const w = watercolorCanvas.clientWidth;
                    const h = watercolorCanvas.clientHeight;
                    if (!_paperPatternCanvas && w > 0 && h > 0) _paperPatternCanvas = generatePaperPattern(w, h);
                    if (!_paperPatternCanvas) return;

                    // tile the pattern across the canvas with multiply/overlay effect
                    wcCtx.save();
                    wcCtx.globalAlpha = 0.18; // subtle strength
                    wcCtx.globalCompositeOperation = 'multiply';
                    const pat = wcCtx.createPattern(_paperPatternCanvas, 'repeat');
                    wcCtx.fillStyle = pat;
                    wcCtx.fillRect(0, 0, watercolorCanvas.clientWidth, watercolorCanvas.clientHeight);
                    wcCtx.globalCompositeOperation = 'source-over';
                    wcCtx.restore();
                } catch (err) { /* ignore */ }
            }
                // size & position for color wheel (show half on left)
                const containerSize = (120 * 2) + 30; // BUTTON_RADIUS * 2 + 30
                colorPalette.style.width = `${120 * 2}px`;
                colorPalette.style.height = `${120 * 2}px`;
                colorWheelContainer.style.width = `${containerSize}px`;
                colorWheelContainer.style.height = `${containerSize}px`;
                if (window.innerWidth <= 720) {
                    // mobile: top-centered
                    colorWheelContainer.style.left = '50%';
                    colorWheelContainer.style.top = '12px';
                    colorWheelContainer.style.transform = 'translateX(-50%)';
                    hoverTextDisplay.style.left = `${Math.floor(containerSize / 2) + 14}px`;
                } else {
                    colorWheelContainer.style.left = `-${Math.floor(containerSize / 2)}px`;
                    hoverTextDisplay.style.left = `${containerSize + 20}px`;
                }
            }

            function createColorPaletteTop() {
                colorPalette.innerHTML = '';
                const NUM_BUTTONS = 18;
                // adapt sizes for mobile
                const isMobile = window.innerWidth <= 720;
                const BUTTON_RADIUS = isMobile ? 88 : 120;
                const BUTTON_SIZE = isMobile ? 48 : 60;

                    const angleStep = 360 / NUM_BUTTONS;
                    for (let i = 0; i < NUM_BUTTONS; i++) {
                        const angle = i * angleStep; // degrees like simulation2
                        const radians = angle * (Math.PI / 180);

                        const btn = document.createElement('div');
                        btn.className = 'color-button';

                        // compute position inside the circular palette container (same math as simulation2)
                        const x = BUTTON_RADIUS + BUTTON_RADIUS * Math.cos(radians) - BUTTON_SIZE / 2;
                        const y = BUTTON_RADIUS + BUTTON_RADIUS * Math.sin(radians) - BUTTON_SIZE / 2;
                        btn.style.left = `${x}px`;
                        btn.style.top = `${y}px`;

                        const color = COLORS[i % COLORS.length];
                        btn.style.background = color;
                        btn.style.setProperty('--initial-rotation-compensate', `-${angle}deg`);

                    btn.addEventListener('mouseenter', () => {
                        hoverTextDisplay.style.opacity = '1';
                        hoverTextDisplay.textContent = color;
                        setTimeout(() => { hoverTextDisplay.style.opacity = '0'; }, 900);
                    });

                    btn.addEventListener('click', () => {
                        currentDrawColor = color;
                        // expose color selection for GPU input to pick up
                        window.currentDrawColorGlobal = color;
                        colorPointer.style.backgroundColor = color;
                        colorPointer.style.boxShadow = `0 0 0 2px ${color}, 0 4px 10px rgba(0,0,0,0.2)`;
                                // If GPU buffer exists, update it too (rendering uniform)
                                if (currentColorBufferGlobal && deviceGlobal) {
                                    deviceGlobal.queue.writeBuffer(currentColorBufferGlobal, 0, new Float32Array(hexToRgbaArray(color)));
                                }
                    });

                    btn.addEventListener('mouseover', () => {
                        colorPointer.style.boxShadow = `0 0 0 2px ${color}, 0 4px 10px rgba(0, 0, 0, 0.2)`;
                        colorPointer.style.backgroundColor = color;
                    });

                    btn.addEventListener('mouseout', () => {
                        colorPointer.style.backgroundColor = currentDrawColor;
                        colorPointer.style.boxShadow = `0 0 0 2px ${currentDrawColor}, 0 4px 10px rgba(0,0,0,0.2)`;
                    });

                    colorPalette.appendChild(btn);
                }

                // set initial pointer color
                colorPointer.style.backgroundColor = currentDrawColor;
                colorPointer.style.boxShadow = `0 0 0 2px ${currentDrawColor}, 0 4px 10px rgba(0,0,0,0.2)`;
            }

            function createIrregularShape(context, cx, cy, radius) {
                const numPoints = 8 + Math.floor(Math.random() * 5);
                context.beginPath();
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const irregularity = 0.7 + Math.random() * 0.6;
                    const currentRadius = radius * irregularity;
                    const x = cx + Math.cos(angle) * currentRadius;
                    const y = cy + Math.sin(angle) * currentRadius;
                    if (i === 0) context.moveTo(x, y);
                    else {
                        const prevX = cx + Math.cos(((i - 1) / numPoints) * Math.PI * 2) * radius * (0.7 + Math.random() * 0.6);
                        const prevY = cy + Math.sin(((i - 1) / numPoints) * Math.PI * 2) * radius * (0.7 + Math.random() * 0.6);
                        const cp1x = cx + Math.cos(angle - (Math.PI / numPoints) * 0.5) * radius * (0.8 + Math.random() * 0.4);
                        const cp1y = cy + Math.sin(angle - (Math.PI / numPoints) * 0.5) * radius * (0.8 + Math.random() * 0.4);
                        context.bezierCurveTo(prevX, prevY, cp1x, cp1y, x, y);
                    }
                }
                context.closePath();
            }

            // Draw a watercolor-like blob.
            // Uses randomized layered strokes and multi-pass blurs to emulate
            // paint diffusion and granulation; directional smear (vx/vy) removed.
            // Schedules subtle immediate spread passes to approximate bleeding.
            // High-fidelity watercolor blob renderer
            // - uses an offscreen canvas to compose layered pigment, rings, speckles and blurred diffusion
            // - pressure controls opacity and mixing
            // - vx,vy provide smear direction
            function drawWatercolorBlob(x, y, currentSpreadRadius, pressure = 1.0, vx = 0, vy = 0) {
                // use an adjusted copy of the selected color for drawing so palette
                // hex remains untouched while the on-canvas appearance is slightly
                // brighter/clearer (more saturated / lighter) for a translucent watercolor look
                function adjustHexForDrawing(hex, lightBoost = 0.06, satBoost = 0.06) {
                    // convert hex -> r,g,b (0..1)
                    const r = parseInt(hex.slice(1,3),16) / 255;
                    const g = parseInt(hex.slice(3,5),16) / 255;
                    const b = parseInt(hex.slice(5,7),16) / 255;
                    // convert to HSL
                    const max = Math.max(r,g,b), min = Math.min(r,g,b);
                    let h = 0, s = 0, l = (max+min)/2;
                    if (max !== min) {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch(max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    // apply small boosts
                    l = Math.min(1, l + lightBoost);
                    s = Math.min(1, s + satBoost);

                    // convert HSL back to RGB
                    function hue2rgb(p, q, t) {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    }
                    let rr, gg, bb;
                    if (s === 0) { rr = gg = bb = l; }
                    else {
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        rr = hue2rgb(p, q, h + 1/3);
                        gg = hue2rgb(p, q, h);
                        bb = hue2rgb(p, q, h - 1/3);
                    }
                    // convert back to hex
                    function toHex(v) { return Math.max(0, Math.min(255, Math.round(v * 255))).toString(16).padStart(2,'0'); }
                    return `#${toHex(rr)}${toHex(gg)}${toHex(bb)}`;
                }

                // stronger render-only boost so strokes look clearer/more luminous
                const drawColorHex = adjustHexForDrawing(currentDrawColor, 0.14, 0.14);
                wcCtx.save();
                // use normal alpha compositing by default so overlapping colors remain translucent
                wcCtx.globalCompositeOperation = 'source-over';

                // Map pressure (0..1) into requested opacity range [0.2, 0.5]
                const clampedPressure = Math.max(0, Math.min(1, pressure));
                // make base paint more saturated/visible for vivid colors (allow stronger extremes)
                const basePaintAlpha = Math.min(0.95, 0.45 + clampedPressure * 0.5); // ~0.45 .. 0.95
                const watercolorColor = hexToRgba(drawColorHex, basePaintAlpha);

                const baseBrushRadius = currentSpreadRadius * 0.8;
                // derive paint opacity / lifetime and per-stamp parameters
                const initialAlpha = Math.max(0.18, Math.min(1.0, (0.8 + clampedPressure * 0.2) * (0.8 + simConfig.mixingStrength * 0.3)));
                const lifespan = Math.max(300, Math.round(1800 / Math.max(0.18, simConfig.dryingSpeed)));
                // number of fine strokes increases with brush size and granulation
                const numStrokes = Math.max(8, Math.floor(8 + baseBrushRadius * 0.12 + simConfig.granulation * 36));
                const blurAmount = baseBrushRadius * (0.4 + simConfig.granulation * 0.6);

                // create an offscreen canvas sized to contain the largest spread
                const ratio = window.devicePixelRatio || 1;
                const offsize = Math.ceil((baseBrushRadius * (1 + MAX_SPREAD_FACTOR)) * 4 * ratio);
                let off = document.createElement('canvas');
                off.width = offsize; off.height = offsize;
                const oc = off.getContext('2d');
                oc.setTransform(ratio, 0, 0, ratio, 0, 0);
                try { oc.imageSmoothingEnabled = true; } catch (err) { /* ignore */ }

                // center of the offscreen blot in CSS pixels
                const cx = off.width / (2 * ratio);
                const cy = off.height / (2 * ratio);

                // Compute pointer velocity influence for directional flow
                const velMag = Math.sqrt((vx || 0) * (vx || 0) + (vy || 0) * (vy || 0));
                const nx = velMag > 0 ? (vx / velMag) : 0;
                const ny = velMag > 0 ? (vy / velMag) : 0;
                // flowScale determines how much stamps/bleeds bias along motion
                const flowScale = Math.min(1.0, velMag / 160) * (simConfig.flowStrength || 0.6);

                // Color mixing: sample underlying pixels in a small box and mix the stroke color
                // Amount of mixing increases with pressure and with larger brush
                let mixedCenterColor = null;
                try {
                    const ratio = window.devicePixelRatio || 1;
                    const samplePx = Math.max(4, Math.floor(baseBrushRadius * 0.12));
                    const sx = Math.floor(Math.max(0, (x - samplePx / 2) * ratio));
                    const sy = Math.floor(Math.max(0, (y - samplePx / 2) * ratio));
                    const sw = Math.min(Math.floor(samplePx * ratio), watercolorCanvas.width - sx);
                    const sh = Math.min(Math.floor(samplePx * ratio), watercolorCanvas.height - sy);
                    if (sw > 0 && sh > 0) {
                        const data = wcCtx.getImageData(sx, sy, sw, sh).data;
                        let rSum = 0, gSum = 0, bSum = 0, count = 0;
                        for (let i = 0; i < data.length; i += 4) {
                    const initialAlpha = Math.max(0.18, Math.min(1.0, (0.8 + clampedPressure * 0.2) * (0.8 + simConfig.mixingStrength * 0.3))) + (Math.random() - 0.5) * 0.1;
                            gSum += data[i + 1];
                            bSum += data[i + 2];
                            count++;
                        }
                        if (count > 0) {
                            const ar = rSum / count / 255;
                            const ag = gSum / count / 255;
                            const ab = bSum / count / 255;

                            // mixing weight depends on pressure and global mixingStrength
                            const mixStrength = Math.min(0.95, simConfig.mixingStrength * (0.25 + clampedPressure * 0.75));
                            const src = hexToRgbaArray(drawColorHex);
                            const mixedR = src[0] * (1 - mixStrength) + ar * mixStrength;
                            const mixedG = src[1] * (1 - mixStrength) + ag * mixStrength;
                            const mixedB = src[2] * (1 - mixStrength) + ab * mixStrength;
                            mixedCenterColor = `rgba(${Math.floor(mixedR * 255)}, ${Math.floor(mixedG * 255)}, ${Math.floor(mixedB * 255)}, ${basePaintAlpha})`;
                        }
                    }
                } catch (err) { /* getImageData may fail on cross-origin or very large canvases; ignore */ }

                // Draw multiple soft irregular strokes to offscreen canvas so we can blur and composite
                for (let i = 0; i < numStrokes; i++) {
                    const t = i / numStrokes; // 0..1 across strokes
                    const radius = baseBrushRadius * (0.6 + Math.random() * 0.9) * (1 + t * 0.4);
                    // directional bias
                    // non-directional jitter instead of motion-aligned smear
                    const jitter = (Math.random() - 0.5) * blurAmount * (1 + t * 0.5);
                    // combine random jitter with motion bias to create directional flow
                    const motionBias = flowScale * baseBrushRadius * 0.18 * (0.6 + Math.random() * 0.8);
                    const offsetX = jitter + (Math.random() - 0.5) * baseBrushRadius * 0.08 + nx * motionBias * (0.6 + Math.random() * 0.8);
                    const offsetY = (Math.random() - 0.5) * blurAmount * (1 + t * 0.5) + (Math.random() - 0.5) * baseBrushRadius * 0.08 + ny * motionBias * (0.6 + Math.random() * 0.8);

                    // stroke alpha factors: base translucency, pressure and granulation
                    const strokeAlpha = (0.01 + Math.random() * 0.06) * (1 - t * 0.85) * (0.6 + clampedPressure * 0.6) * (0.6 + simConfig.granulation * 0.8);
                                                // mixing strength controlled globally and modulated by pressure
                                                const mixStrength = Math.min(0.95, simConfig.mixingStrength * (0.25 + clampedPressure * 0.75));
                    oc.globalAlpha = strokeAlpha;
                    oc.fillStyle = watercolorColor;
                    if (i % 4 === 0) oc.filter = `blur(${1.5 + t * 3.5}px)`;
                    else oc.filter = 'none';

                    // draw irregular shape around center (cx,cy)
                    oc.beginPath();
                    // reuse createIrregularShape logic but draw to offscreen
                    const numPoints = 8 + Math.floor(Math.random() * 6);
                    for (let p = 0; p < numPoints; p++) {
                        const a = (p / numPoints) * Math.PI * 2;
                        const ir = radius * (0.7 + Math.random() * 0.7);
                        const px = cx + Math.cos(a) * ir + offsetX;
                        const py = cy + Math.sin(a) * ir + offsetY;
                        if (p === 0) oc.moveTo(px, py);
                        else oc.lineTo(px, py);
                    }
                    oc.closePath();
                    oc.fill();
                    oc.filter = 'none';
                }

                // Stronger center stroke (less blurred) to represent concentrated pigment
                wcCtx.filter = 'none';
                // core: darker, concentrated pigment toward center
                // core: darker, concentrated pigment toward center
                oc.globalAlpha = Math.min(0.95, 0.32 + clampedPressure * 0.48 + simConfig.mixingStrength * 0.15);
                oc.fillStyle = mixedCenterColor || hexToRgba(drawColorHex, Math.min(0.95, basePaintAlpha + 0.15));
                oc.beginPath();
                // smaller, dense irregular core
                const coreR = baseBrushRadius * 0.6;
                for (let p = 0; p < 10; p++) {
                    const a = (p / 10) * Math.PI * 2;
                    const r = coreR * (0.7 + Math.random() * 0.5);
                    // small random displacement for irregular core, no directional smear
                    const px = cx + Math.cos(a) * r + (Math.random() - 0.5) * coreR * 0.12;
                    const py = cy + Math.sin(a) * r + (Math.random() - 0.5) * coreR * 0.12;
                    if (p === 0) oc.moveTo(px, py);
                    else oc.lineTo(px, py);
                }
                oc.closePath();
                oc.fill();
                    // - directional smear was removed; we use randomized jitter and rotation
                // add a ring: draw a darker thin outline then blur heavily to create pigment-edge ring
                oc.globalAlpha = 0.42 + clampedPressure * 0.5 + simConfig.granulation * 0.35;
                oc.strokeStyle = hexToRgba(drawColorHex, Math.min(0.95, basePaintAlpha + 0.25));
                oc.lineWidth = Math.max(2, coreR * 0.12);
                oc.beginPath();
                const ringR = coreR * (1.0 + 0.25 * Math.random());
                for (let p = 0; p < 24; p++) {
                    const a = (p / 24) * Math.PI * 2;
                    const r = ringR * (0.85 + Math.random() * 0.35);
                    const px = cx + Math.cos(a) * r;
                    const py = cy + Math.sin(a) * r;
                    if (p === 0) oc.moveTo(px, py);
                    else oc.lineTo(px, py);
                }
                oc.closePath();
                oc.stroke();

                // darken the rim a bit to simulate pigment aggregation at the edge
                try {
                    oc.save();
                    oc.globalCompositeOperation = 'multiply';
                    // reduce rim darken alpha so edges don't drive overlapping into black
                    oc.globalAlpha = 0.12 + clampedPressure * 0.12;
                    oc.filter = `blur(${Math.max(2, coreR * 0.8)}px)`;
                    oc.fillStyle = 'rgba(0,0,0,0.26)';
                    createIrregularShape(oc, cx, cy, ringR * 1.6);
                    oc.fill();
                    oc.filter = 'none';
                    oc.restore();
                } catch (err) { /* ignore */ }

                // speckles (pigment granulation). Draw small scattered darker dots then blur
                // toning down speckle alpha to keep overall texture translucent
                oc.globalAlpha = 0.32 * clampedPressure * (0.6 + simConfig.granulation * 0.8);
                for (let s = 0; s < Math.floor(coreR * (1.8 + simConfig.granulation * 2.8)); s++) {
                    const sx = cx + (Math.random() - 0.5) * coreR * 2.3;
                    const sy = cy + (Math.random() - 0.5) * coreR * 2.3;
                    const r = Math.random() * (Math.max(1, coreR * 0.04));
                    oc.beginPath(); oc.arc(sx, sy, r, 0, Math.PI * 2); oc.fill();
                }

                // do a multi-pass blur using temporary canvases to simulate diffusion
                // small blur pass
                const blurA = 2 + simConfig.spreadFactor * 0.6;
                oc.filter = `blur(${Math.max(1.2, blurA)}px)`;
                const tmp1 = document.createElement('canvas'); tmp1.width = off.width; tmp1.height = off.height;
                const t1 = tmp1.getContext('2d'); t1.drawImage(off, 0, 0);
                // medium blur pass (blend lighter)
                t1.filter = 'none';
                oc.clearRect(0, 0, off.width, off.height);
                oc.drawImage(tmp1, 0, 0);

                // Instead of stamping directly into the dry canvas, push this offscreen
                // blob into the wet-layer queue. The wet-layer will render each frame and
                // dry+composite the blobs into the dry canvas when finished.
                const drawX = x - cx;
                const drawY = y - cy;
                // initialAlpha & lifespan were already computed earlier for this stamp

                // We no longer queue wet blobs — wet animation removed.
                // Immediately stamp the composed offscreen blob onto the dry canvas
                // using multiple passes to simulate watercolor bleeding/softening.
                try {
                    // multi-pass wash layers (wet-on-wet if enabled) — paint softer larger underlying washes first
                    const washes = Math.max(0, Math.floor(simConfig.washLayers || 0));
                    if (washes > 0) {
                        for (let wl = 0; wl < washes; wl++) {
                            try {
                                const t = washes <= 1 ? 0 : wl / (washes - 1);
                                const scale = 1 + 0.28 + t * (0.9 + Math.random() * 0.8);
                                const blurPx = 2 + t * (6 + simConfig.bleedIntensity * 8);
                                const alphaW = Math.max(0.02, Math.min(0.4, initialAlpha * (0.08 + (1 - t) * 0.16) * (0.8 + simConfig.bleedIntensity * 0.6)));
                                const driftX = (Math.random() - 0.5) * baseBrushRadius * 0.18 * (1 + t);
                                const driftY = (Math.random() - 0.5) * baseBrushRadius * 0.18 * (1 + t);

                                const targetCtx = wetCtx || wcCtx;
                                targetCtx.save();
                                // wet-on-wet blends should be gentle; prefer screen to avoid hard darkening
                                targetCtx.globalCompositeOperation = simConfig.wetOnWet ? 'screen' : 'source-over';
                                targetCtx.globalAlpha = alphaW;
                                targetCtx.filter = `blur(${Math.max(1, blurPx)}px)`;
                                targetCtx.translate(drawX + cx + driftX, drawY + cy + driftY);
                                targetCtx.rotate((Math.random() - 0.5) * 0.7);
                                targetCtx.drawImage(off, -cx * scale, -cy * scale, cx * 2 * scale, cy * 2 * scale);
                                targetCtx.filter = 'none';
                                targetCtx.restore();
                            } catch (err) { /* ignore wash failures */ }
                        }
                    }

                    // base stamp (soft blurred base) -> write to wet layer first so it can flow
                    if (wetCtx) {
                        try {
                            wetCtx.save();
                            wetCtx.globalCompositeOperation = 'source-over';
                            wetCtx.globalAlpha = Math.min(1.0, initialAlpha * 1.05);
                            wetCtx.filter = 'blur(1.5px)';
                            wetCtx.drawImage(off, drawX, drawY, cx * 2, cy * 2);
                            wetCtx.filter = 'none';
                            wetCtx.restore();

                            // directional trail for faster motion
                            if (flowScale > 0.06) {
                                try {
                                    const stretch = 1 + flowScale * (0.6 + Math.random() * 1.2);
                                    const trailAlpha = Math.min(0.6, initialAlpha * (0.28 + flowScale * 0.9));
                                    const sx = drawX + nx * baseBrushRadius * (0.6 + Math.random() * 1.0);
                                    const sy = drawY + ny * baseBrushRadius * (0.6 + Math.random() * 1.0);
                                    wetCtx.save();
                                    wetCtx.globalCompositeOperation = 'source-over';
                                    wetCtx.globalAlpha = trailAlpha;
                                    wetCtx.filter = `blur(${Math.max(1.6, baseBrushRadius * 0.12 * stretch)}px)`;
                                    const ang = Math.atan2(ny, nx) + (Math.random() - 0.5) * 0.6;
                                    wetCtx.translate(sx + cx, sy + cy);
                                    wetCtx.rotate(ang);
                                    wetCtx.drawImage(off, -cx * stretch, -cy * (stretch * 0.6), cx * 2 * stretch, cy * 2 * (stretch * 0.6));
                                    wetCtx.filter = 'none';
                                    wetCtx.restore();
                                } catch (err) { /* ignore flow paint */ }
                            }

                            // small randomized brush-shaped particles around the stamp
                            try {
                                const particleCount = Math.max(2, Math.min(20, Math.floor(baseBrushRadius * 0.04) + Math.floor(Math.random() * 6)));
                                for (let pI = 0; pI < particleCount; pI++) {
                                    const psize = Math.max(6, Math.round(baseBrushRadius * (0.08 + Math.random() * 0.18)));
                                    const pc = document.createElement('canvas'); pc.width = psize * 2; pc.height = psize * 2;
                                    const pct = pc.getContext('2d');
                                    try { pct.imageSmoothingEnabled = true; } catch (err) {}
                                    const px = pc.width / 2, py = pc.height / 2;
                                    pct.save();
                                    pct.translate(px, py);
                                    const ang = (Math.random() - 0.5) * Math.PI;
                                    pct.rotate(ang);
                                    // create an elongated irregular brush shape
                                    pct.beginPath();
                                    const points = 5 + Math.floor(Math.random() * 4);
                                    for (let pp = 0; pp < points; pp++) {
                                        const a = (pp / points) * Math.PI * 2;
                                        const r = psize * (0.5 + Math.random() * 0.9);
                                        const rx = Math.cos(a) * r * (0.6 + Math.random() * 0.9);
                                        const ry = Math.sin(a) * r * (0.4 + Math.random() * 0.6);
                                        if (pp === 0) pct.moveTo(rx, ry); else pct.lineTo(rx, ry);
                                    }
                                    pct.closePath();
                                    pct.fillStyle = hexToRgba(drawColorHex, 0.65 * (0.4 + Math.random() * 0.8));
                                    pct.fill();
                                    pct.restore();

                                    // random placement around the main blob with soft alpha
                                    const offx = (Math.random() - 0.5) * baseBrushRadius * (0.2 + Math.random() * 1.2);
                                    const offy = (Math.random() - 0.5) * baseBrushRadius * (0.2 + Math.random() * 1.2);
                                    wetCtx.save();
                                    wetCtx.globalCompositeOperation = 'screen';
                                    wetCtx.globalAlpha = 0.06 + Math.random() * 0.12;
                                    wetCtx.filter = `blur(${Math.max(0.5, psize * 0.15)}px)`;
                                    wetCtx.drawImage(pc, drawX + cx + offx - pc.width/2, drawY + cy + offy - pc.height/2);
                                    wetCtx.filter = 'none';
                                    wetCtx.restore();
                                }
                            } catch (err) { /* ignore particle generation errors */ }
                        } catch (err) { /* ignore */ }
                    } else {
                        wcCtx.save();
                        wcCtx.globalCompositeOperation = 'source-over';
                        wcCtx.globalAlpha = initialAlpha;
                        wcCtx.filter = 'blur(1.5px)';
                        wcCtx.drawImage(off, drawX, drawY, cx * 2, cy * 2);
                        wcCtx.filter = 'none';
                        wcCtx.restore();
                    }

                    // subtle pigment separation (chromatography effect)
                    if (simConfig.pigmentSeparation > 0) {
                        try {
                            const sep = Math.max(0.5, Math.round(simConfig.pigmentSeparation * baseBrushRadius));
                            const rgba = hexToRgbaArray(drawColorHex);
                            const r255 = Math.floor(rgba[0] * 255);
                            const g255 = Math.floor(rgba[1] * 255);
                            const b255 = Math.floor(rgba[2] * 255);

                            function makeTintedCanvas(r, g, b) {
                                const tc = document.createElement('canvas'); tc.width = off.width; tc.height = off.height;
                                const tctx = tc.getContext('2d');
                                tctx.drawImage(off, 0, 0);
                                tctx.globalCompositeOperation = 'source-in';
                                tctx.fillStyle = `rgba(${r},${g},${b},1)`;
                                tctx.fillRect(0, 0, tc.width, tc.height);
                                tctx.globalCompositeOperation = 'source-over';
                                return tc;
                            }

                            const rC = makeTintedCanvas(r255, 0, 0);
                            const gC = makeTintedCanvas(0, g255, 0);
                            const bC = makeTintedCanvas(0, 0, b255);

                            if (wetCtx) {
                                wetCtx.save(); wetCtx.globalCompositeOperation = 'screen'; wetCtx.globalAlpha = Math.min(0.62, initialAlpha * 0.6);
                                wetCtx.drawImage(rC, drawX - sep, drawY, cx * 2, cy * 2);
                                wetCtx.restore();
                            } else {
                                wcCtx.save(); wcCtx.globalCompositeOperation = 'screen'; wcCtx.globalAlpha = Math.min(0.62, initialAlpha * 0.6);
                                wcCtx.drawImage(rC, drawX - sep, drawY, cx * 2, cy * 2);
                                wcCtx.restore();
                            }

                            if (wetCtx) {
                                wetCtx.save(); wetCtx.globalCompositeOperation = 'screen'; wetCtx.globalAlpha = Math.min(0.52, initialAlpha * 0.46);
                                wetCtx.drawImage(gC, drawX + Math.round(sep * 0.6), drawY + Math.round(sep * 0.35), cx * 2, cy * 2);
                                wetCtx.restore();
                            } else {
                                wcCtx.save(); wcCtx.globalCompositeOperation = 'screen'; wcCtx.globalAlpha = Math.min(0.52, initialAlpha * 0.46);
                                wcCtx.drawImage(gC, drawX + Math.round(sep * 0.6), drawY + Math.round(sep * 0.35), cx * 2, cy * 2);
                                wcCtx.restore();
                            }

                            if (wetCtx) {
                                wetCtx.save(); wetCtx.globalCompositeOperation = 'screen'; wetCtx.globalAlpha = Math.min(0.42, initialAlpha * 0.36);
                                wetCtx.drawImage(bC, drawX + sep, drawY - Math.round(sep * 0.4), cx * 2, cy * 2);
                                wetCtx.restore();
                            } else {
                                wcCtx.save(); wcCtx.globalCompositeOperation = 'screen'; wcCtx.globalAlpha = Math.min(0.42, initialAlpha * 0.36);
                                wcCtx.drawImage(bC, drawX + sep, drawY - Math.round(sep * 0.4), cx * 2, cy * 2);
                                wcCtx.restore();
                            }
                        } catch (err) { /* ignore */ }
                    }

                    // Immediate spread passes (faked diffusion) — layered, blurred, faint
                    const spreadSteps = Math.max(3, Math.floor(4 + simConfig.spreadFactor * 0.9));
                    for (let s = 1; s <= spreadSteps; s++) {
                        const stepT = s / spreadSteps; // [0..1]
                        // non-directional random drift for spread (remove straight-line smear)
                        // bias spread slightly along motion to create flow
                        const driftX = (Math.random() - 0.5) * 8 * stepT + (Math.random() - 0.5) * baseBrushRadius * 0.02 + nx * baseBrushRadius * flowScale * (0.22 + stepT * 0.46);
                        const driftY = (Math.random() - 0.5) * 8 * stepT + (Math.random() - 0.5) * baseBrushRadius * 0.02 + ny * baseBrushRadius * flowScale * (0.22 + stepT * 0.46);
                        const sw = cx * 2 * (1 + stepT * 0.8);
                        const sh = cy * 2 * (1 + stepT * 0.8);

                        // spread pass: draw with slight rotation/jitter to avoid linear repeats
                        try {
                            const angle = (Math.random() - 0.5) * 1.2; // randomized rotation
                            const jx = (Math.random() - 0.5) * baseBrushRadius * 0.06;
                            const jy = (Math.random() - 0.5) * baseBrushRadius * 0.06;
                            if (wetCtx) {
                                wetCtx.save();
                                wetCtx.translate(drawX + cx + driftX + jx, drawY + cy + driftY + jy);
                                wetCtx.rotate(angle);
                                wetCtx.globalCompositeOperation = 'source-over';
                                wetCtx.filter = `blur(${2 + stepT * 6}px)`;
                                // slightly stronger fades for more visible bleed layers
                                wetCtx.globalAlpha = Math.max(0.01, 0.08 * (1 - stepT));
                                wetCtx.drawImage(off, -sw / 2, -sh / 2, sw, sh);
                                wetCtx.filter = 'none';
                                wetCtx.restore();
                            } else {
                                wcCtx.save();
                                wcCtx.translate(drawX + cx + driftX + jx, drawY + cy + driftY + jy);
                                wcCtx.rotate(angle);
                                wcCtx.globalCompositeOperation = 'source-over';
                                wcCtx.filter = `blur(${2 + stepT * 6}px)`;
                                // slightly stronger fades for more visible bleed layers
                                wcCtx.globalAlpha = Math.max(0.01, 0.08 * (1 - stepT));
                                wcCtx.drawImage(off, -sw / 2, -sh / 2, sw, sh);
                                wcCtx.filter = 'none';
                                wcCtx.restore();
                            }
                        } catch (err) { /* ignore */ }
                    }

                    // After spreading into the wet layer, deposit some pigment to dry canvas
                    if (wetCtx) {
                        try {
                            const depositAlpha = Math.max(0.03, initialAlpha * (0.42 + simConfig.bleedIntensity * 0.36));
                            wcCtx.save(); wcCtx.globalCompositeOperation = 'source-over'; wcCtx.globalAlpha = depositAlpha;
                            wcCtx.drawImage(watercolorWetCanvas, drawX, drawY, cx * 2, cy * 2);
                            // subtle white sheen deposit to emphasize wet, bleeding highlights
                            try {
                                wcCtx.save();
                                wcCtx.globalCompositeOperation = 'screen';
                                wcCtx.globalAlpha = Math.min(0.08, depositAlpha * 0.18);
                                const g2 = wcCtx.createRadialGradient(drawX + cx, drawY + cy, Math.max(2, baseBrushRadius * 0.12), drawX + cx, drawY + cy, baseBrushRadius * 0.9);
                                g2.addColorStop(0, 'rgba(255,255,255,0.9)');
                                g2.addColorStop(1, 'rgba(255,255,255,0)');
                                wcCtx.fillStyle = g2;
                                wcCtx.beginPath(); wcCtx.arc(drawX + cx, drawY + cy, baseBrushRadius * 1.0, 0, Math.PI * 2); wcCtx.fill();
                                wcCtx.restore();
                            } catch (err) { /* ignore highlight deposit issues */ }
                            wcCtx.restore();

                            // partially dry the wet region so it fades and won't spread forever
                            wetCtx.save();
                            wetCtx.globalCompositeOperation = 'destination-out';
                            wetCtx.globalAlpha = Math.min(0.32, 0.06 + (1.0 / Math.max(0.6, simConfig.dryingSpeed)) * 0.12);
                            wetCtx.fillStyle = 'rgba(0,0,0,1)';
                            wetCtx.fillRect(drawX, drawY, cx * 2, cy * 2);
                            wetCtx.restore();
                        } catch (err) { /* ignore deposit issues */ }
                    }

                    // subtle irregular fill to add textured edge / capillary effect
                    wcCtx.save();
                    wcCtx.globalCompositeOperation = 'source-over';
                    wcCtx.globalAlpha = 0.03 + Math.min(0.18, simConfig.granulation * 0.1);
                    wcCtx.fillStyle = hexToRgba(drawColorHex, Math.min(0.9, basePaintAlpha * 0.6));
                    const sRadius = baseBrushRadius * (1 + 0.4) + Math.random() * 6;
                    createIrregularShape(wcCtx, x + (Math.random() - 0.5) * 6, y + (Math.random() - 0.5) * 6, sRadius);
                    wcCtx.fill();
                    wcCtx.restore();

                    // backrun / edge bleed simulation: small radial runs and tails
                    if (simConfig.backrunStrength > 0.001) {
                        try {
                            const runs = Math.max(1, Math.floor(simConfig.backrunStrength * 18));
                            for (let r = 0; r < runs; r++) {
                                const angle = Math.random() * Math.PI * 2;
                                const len = baseBrushRadius * (0.6 + Math.random() * 1.8) * (0.4 + simConfig.backrunStrength);
                                const jitter = (Math.random() - 0.5) * baseBrushRadius * 0.06;
                                const px = x + Math.cos(angle) * (coreR * (0.9 + Math.random() * 0.6));
                                const py = y + Math.sin(angle) * (coreR * (0.9 + Math.random() * 0.6));
                                wcCtx.save();
                                wcCtx.translate(px + jitter, py + jitter);
                                wcCtx.rotate(angle + (Math.random() - 0.5) * 0.6);
                                wcCtx.globalCompositeOperation = 'source-over';
                                wcCtx.globalAlpha = Math.min(0.42, initialAlpha * (0.25 + Math.random() * 0.9) * simConfig.backrunStrength);
                                wcCtx.filter = `blur(${2 + Math.random() * 8}px)`;
                                // elongated irregular shape representing a capillary run
                                const runRadius = Math.max(3, len);
                                wcCtx.fillStyle = hexToRgba(drawColorHex, Math.min(0.9, basePaintAlpha * (0.8 + Math.random() * 0.25)));
                                wcCtx.beginPath();
                                const segs = 6 + Math.floor(Math.random() * 5);
                                for (let p = 0; p < segs; p++) {
                                    const t = p / (segs - 1);
                                    // taper at the tail (wider near start, narrower at end)
                                    const rr = runRadius * (1.0 - t * (0.6 + Math.random() * 0.45));
                                    const ax = t * len * (0.3 + Math.random() * 1.3) - len * 0.15;
                                    const ay = (Math.random() - 0.5) * rr * 0.6;
                                    if (p === 0) wcCtx.moveTo(ax, ay);
                                    else wcCtx.lineTo(ax, ay);
                                }
                                wcCtx.closePath();
                                wcCtx.fill();
                                wcCtx.filter = 'none';
                                wcCtx.restore();
                            }
                        } catch (err) { /* ignore backrun failures */ }
                    }

                    // rim darkening to emphasize edges (subtle but visible)
                    const rimCtx = wetCtx || wcCtx;
                    rimCtx.save();
                    rimCtx.globalCompositeOperation = 'source-over';
                    rimCtx.globalAlpha = Math.min(0.28, 0.08 + basePaintAlpha * 0.28);
                    rimCtx.filter = `blur(${Math.max(1.2, baseBrushRadius * 0.08)}px)`;
                    rimCtx.strokeStyle = 'rgba(0,0,0,0.5)';
                    rimCtx.lineWidth = Math.max(1, baseBrushRadius * 0.06);
                    createIrregularShape(rimCtx, x, y, baseBrushRadius * 1.1);
                    rimCtx.stroke();
                    rimCtx.filter = 'none';
                    rimCtx.restore();

                    // soft highlight in the center to simulate wet sheen / light catch
                    const highlightCtx = wetCtx || wcCtx;
                    highlightCtx.save();
                    highlightCtx.globalCompositeOperation = 'screen';
                    // make the white sheen more visible for wetter-looking watercolor
                    highlightCtx.globalAlpha = 0.16 + Math.min(0.28, clampedPressure * 0.28);
                    const grad = highlightCtx.createRadialGradient(x, y, Math.max(2, baseBrushRadius * 0.18), x, y, baseBrushRadius * 1.1);
                    grad.addColorStop(0, 'rgba(255,255,255,0.85)');
                    grad.addColorStop(1, 'rgba(255,255,255,0)');
                    highlightCtx.fillStyle = grad;
                    highlightCtx.beginPath(); highlightCtx.arc(x, y, baseBrushRadius * 1.2, 0, Math.PI * 2); highlightCtx.fill();
                    highlightCtx.restore();
                } catch (err) { /* drawing fallback ignore */ }
                // (no asynchronous spread; everything stamped synchronously above)

                wcCtx.restore();
            }

            // overlay event handlers (call window.performGpuInput for GPU side if available)
            // Use pointer events for pressure/touch/stylus compatibility
            watercolorCanvas.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                isDrawingLocal = true;
                spreadStartTime = performance.now();
                const rect = watercolorCanvas.getBoundingClientRect();
                lastPointerX = e.clientX - rect.left;
                lastPointerY = e.clientY - rect.top;
                // pressure is supported on stylus and touch; fallback to 1
                const pressureVal = (typeof e.pressure === 'number' && e.pressure > 0) ? e.pressure : 1.0;
                // capture pointer so we continue receiving events if the pointer goes outside
                try { watercolorCanvas.setPointerCapture(e.pointerId); } catch (err) { /* ignore */ }

                // update visible pointer immediately so it follows while drawing
                try { colorPointer.style.left = `${e.clientX}px`; colorPointer.style.top = `${e.clientY}px`; } catch (err) { /* ignore */ }
                // don't stamp immediately here — start stamping on first move so strokes
                // feel continuous. If the pointer doesn't move before pointerup, we'll
                // emit a single dot on pointerup.
                hasMovedSinceDown = false;
                // call GPU input if GPU has been initialized
                try { window.performGpuInput(e); } catch (err) { /* ignore */ }
                // no wet-layer spread animation — drawing is stamped immediately
            });

            watercolorCanvas.addEventListener('pointermove', (e) => {
                const now = Date.now();
                if (now - lastMoveTime < THROTTLE_TIME) return;
                lastMoveTime = now;
                const rect = watercolorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                // compute deltas using previous pointer coords (do not overwrite until we finish stamping)
                const prevX = lastPointerX;
                const prevY = lastPointerY;
                const dx = x - prevX;
                const dy = y - prevY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                // mark we moved since the last down so pointerup won't create a duplicate dot
                hasMovedSinceDown = true;
                // update the visible pointer while drawing/capturing
                try { colorPointer.style.left = `${e.clientX}px`; colorPointer.style.top = `${e.clientY}px`; } catch (err) { /* ignore */ }
                if (!isDrawingLocal) return;
                // derive a quick dynamic radius from move speed so strokes feel responsive
                // perform interpolation along the movement so stamps are closer together
                // and the stroke appears smooth (avoid visible stepping)
                const spacing = Math.max(4, baseRadius * 0.28);
                const steps = Math.max(1, Math.ceil(dist / spacing));
                const stepVx = dx / steps;
                const stepVy = dy / steps;
                let stampX = prevX;
                let stampY = prevY;
                for (let si = 1; si <= steps; si++) {
                    stampX = prevX + (dx * (si / steps));
                    stampY = prevY + (dy * (si / steps));
                    // small per-step velocity to feed into the blur/flow
                    const svx = stepVx;
                    const svy = stepVy;
                    const speed = Math.sqrt(svx * svx + svy * svy);
                const speedFactor = Math.min(1, speed / 120);
                    const currentRadius = baseRadius + Math.min(1, speed / 120) * baseRadius * 0.6;
                    const pressureVal = (typeof e.pressure === 'number' && e.pressure > 0) ? e.pressure : 1.0;
                    drawWatercolorBlob(stampX, stampY, currentRadius, pressureVal, svx, svy);
                }
                // update last pointer to current point
                lastPointerX = x; lastPointerY = y;
                try { window.performGpuInput(e); } catch (err) { /* ignore */ }
            });

            function pointerUpHandler(e) {
                try { watercolorCanvas.releasePointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                // If the user pressed and released without moving, emit a single
                // small stamp so clicks still create dots. We avoid stamping twice
                // by using the hasMovedSinceDown flag.
                if (!hasMovedSinceDown) {
                    const rect = watercolorCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const pressureVal = (typeof e.pressure === 'number' && e.pressure > 0) ? e.pressure : 1.0;
                    // smaller dot for click-only
                    drawWatercolorBlob(x, y, Math.max(6, Math.round(baseRadius * 0.45)), pressureVal, 0, 0);
                }
                isDrawingLocal = false;
                hasMovedSinceDown = false;
            }

            watercolorCanvas.addEventListener('pointerup', pointerUpHandler);
            watercolorCanvas.addEventListener('pointercancel', pointerUpHandler);

            clearButton.addEventListener('click', () => {
                // clear overlay immediately (both dry and wet layers)
                wcCtx.clearRect(0, 0, watercolorCanvas.width, watercolorCanvas.height);
                wcCtx.fillStyle = 'white'; wcCtx.fillRect(0, 0, watercolorCanvas.width, watercolorCanvas.height);
                if (wetCtx && watercolorWetCanvas) {
                    // clear wet canvas if present (we don't use wet animation anymore)
                    wetCtx.clearRect(0, 0, watercolorWetCanvas.width, watercolorWetCanvas.height);
                }
                // if GPU textures available, reinitialize them via globals
                if (deviceGlobal && inputSimTextureGlobal && outputSimTextureGlobal && initialDataGlobal) {
                    deviceGlobal.queue.writeTexture({ texture: inputSimTextureGlobal }, initialDataGlobal, { bytesPerRow: SIM_SIZE * 4 * 4 }, { width: SIM_SIZE, height: SIM_SIZE });
                    deviceGlobal.queue.writeTexture({ texture: outputSimTextureGlobal }, initialDataGlobal, { bytesPerRow: SIM_SIZE * 4 * 4 }, { width: SIM_SIZE, height: SIM_SIZE });
                }
            });

            // share button: save current drawing and open share view
            const shareButton = document.createElement('button');
            shareButton.id = 'shareButton';
            shareButton.textContent = '만들기';
            shareButton.style.marginTop = '8px';
            shareButton.style.padding = '8px 10px';
            shareButton.style.display = 'inline-block';
            // inject share button below controls (next to home)
            const controlsEl = document.getElementById('controls');
            if (controlsEl) {
                const div = document.createElement('div');
                div.style.marginTop = '8px';
                div.appendChild(shareButton);
                controlsEl.appendChild(div);
            }

            // 홈 버튼: index.html로 이동
            const homeButton = document.getElementById('homeButton');
            if (homeButton) {
                homeButton.addEventListener('click', () => {
                    // navigate to main index page
                    window.location.href = 'index.html';
                });
            }

            // share button handler: composite dry + wet into dataURL and open share.html
            if (shareButton) {
                shareButton.addEventListener('click', () => {
                    try {
                        // composite into offscreen canvas at actual pixel size
                        const off = document.createElement('canvas');
                        off.width = watercolorCanvas.width || watercolorCanvas.clientWidth;
                        off.height = watercolorCanvas.height || watercolorCanvas.clientHeight;
                        const offCtx = off.getContext('2d');
                        // white background
                        offCtx.fillStyle = 'white';
                        offCtx.fillRect(0, 0, off.width, off.height);
                        // draw the dry canvas
                        offCtx.drawImage(watercolorCanvas, 0, 0);
                        // draw wet layer on top if present
                        if (watercolorWetCanvas && watercolorWetCanvas.width > 0) {
                            offCtx.drawImage(watercolorWetCanvas, 0, 0);
                        }
                        const dataUrl = off.toDataURL('image/png');
                        // store into sessionStorage for share.html to read
                        sessionStorage.setItem('sharedDrawing', dataUrl);
                        // open share view in a new tab/window
                        window.open('share.html', '_blank');
                    } catch (err) {
                        console.error('Share failed', err);
                        alert('공유 중 오류가 발생했습니다. 콘솔을 확인해 주세요.');
                    }
                });
            }

            // share / export UI removed — saving and sharing disabled

            // GIF recording removed (feature disabled)

            // create palette and initial layout
            createColorPaletteTop();
            resizeOverlay();
            // pointer follow so colorPointer follows mouse (visible even when cursor hidden)
            document.addEventListener('mousemove', (e) => {
                colorPointer.style.left = `${e.clientX}px`;
                colorPointer.style.top = `${e.clientY}px`;
            });

            // wheel rotates the visible palette
            colorWheelContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rotationSpeed = 15; // degrees per wheel step
                rotationAngle += (e.deltaY > 0 ? -rotationSpeed : rotationSpeed);
                rotationAngle = rotationAngle % 360;
                colorPalette.style.transform = `rotate(${rotationAngle}deg)`;
            });
            // advanced controls removed - settings are fixed above and not user-editable

            // update internal runtime constants when simConfig changes (applied per-draw)

            window.addEventListener('resize', resizeOverlay);
        })();

        // 시뮬레이션 컴퓨트 셰이더 (반응-확산)
        const simulationShaderWGSL = `
            struct SimParams {
                diffusionRateC: f32; // 물감 확산 계수
                diffusionRateW: f32; // 물 확산 계수
                timeStep: f32;       // 시간 간격
                feedRate: f32;       // 물감 주입/소모 비율
                killRate: f32;       // 물 소모 비율
            };

            @group(0) @binding(0) var<uniform> params: SimParams;
            @group(0) @binding(1) var inputSim: texture_2d<f32>; // 텍스처는 픽셀당 하나의 32비트 부동소수점 값
            @group(0) @binding(2) var outputSim: texture_storage_2d<rgba32float, write>; // 출력은 RGBA32F

            // 이웃 픽셀 샘플링을 위한 샘플러 (컴퓨트 셰이더에서는 직접 샘플링 불가, 텍스처 로드로 대체)
            // @group(0) @binding(3) var simSampler: sampler; // 컴퓨트 셰이더에서 샘플러 사용 불가 (texture_2d 사용 시 텍스처는 읽기 전용)

            fn get_pixel(coord: vec2<i32>) -> vec2<f32> {
                // texture_2d는 기본적으로 RGBA 형식이므로 .xy (C, W)를 가져옴
                return textureLoad(inputSim, coord).xy;
            }

            @compute @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE}, 1)
            fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                let coord = vec2<i32>(global_id.xy);
                let sim_size = vec2<i32>(textureDimensions(inputSim));

                // 경계 조건 처리 (안전하게 인덱싱)
                if (coord.x < 0 || coord.x >= sim_size.x || coord.y < 0 || coord.y >= sim_size.y) {
                    return;
                }

                let center = get_pixel(coord);
                var laplacianC = 0.0;
                var laplacianW = 0.0;
                
                // 4방향 이웃 (Neumann 경계 조건 - 가장자리는 자신의 값으로 간주)
                let neighbors = array<vec2<i32>, 4>(
                    vec2<i32>(0, 1), vec2<i32>(0, -1), 
                    vec2<i32>(1, 0), vec2<i32>(-1, 0)
                );

                for (var i = 0; i < 4; i++) {
                    let neighborCoord = coord + neighbors[i];
                    let neighbor = get_pixel(neighborCoord);
                    laplacianC += neighbor.x;
                    laplacianW += neighbor.y;
                }

                laplacianC -= 4.0 * center.x;
                laplacianW -= 4.0 * center.y;

                // 반응-확산 방정식 (Gray-Scott 모델 기반, 수채화 느낌으로 변형)
                let reaction = center.x * center.y * center.y;
                let newC = center.x + params.timeStep * (params.diffusionRateC * laplacianC - reaction + params.feedRate);
                let newW = center.y + params.timeStep * (params.diffusionRateW * laplacianW + reaction - (params.feedRate + params.killRate));
                
                // 값 클램프 (0.0 ~ 1.0 사이 유지)
                let finalC = clamp(newC, 0.0, 1.0);
                let finalW = clamp(newW, 0.0, 1.0);

                textureStore(outputSim, coord, vec4<f32>(finalC, finalW, 0.0, 1.0));
            }
        `;

        // 마우스 입력 컴퓨트 셰이더 (클릭 위치에 물감 주입)
            const inputShaderWGSL = `
            struct InputParams {
                inputX: f32;
                inputY: f32;
                radius: f32;
                colorR: f32;
                colorG: f32;
                colorB: f32;
                pressure: f32; // pointer pressure (0..1)
            };

            @group(0) @binding(0) var<uniform> params: InputParams;
            @group(0) @binding(1) var inputSim: texture_2d<f32>;
            @group(0) @binding(2) var outputSim: texture_storage_2d<rgba32float, write>;

            @compute @workgroup_size(${WORKGROUP_SIZE}, ${WORKGROUP_SIZE}, 1)
            fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
                let coord = vec2<i32>(global_id.xy);
                let sim_size = vec2<f32>(textureDimensions(inputSim));

                let center_x = params.inputX * sim_size.x;
                let center_y = params.inputY * sim_size.y;
                let brush_radius_px = params.radius * sim_size.x;

                let dist = distance(vec2<f32>(coord), vec2<f32>(center_x, center_y));

                let current_values = textureLoad(inputSim, coord).xy; // 현재 C, W 값

                var finalC = current_values.x;
                var finalW = current_values.y;

                if (dist < brush_radius_px) {
                    // 브러시 내부에서 물감 농도 C와 습도 W를 주입
                    let strength = (1.0 - smoothstep(0.0, brush_radius_px, dist)) * params.pressure; // pressure-affected strength

                    // 기존 물감 위에 새 물감을 덧칠하고, 물(W)도 주입
                    // 새로운 C = (이전 C * (1-strength)) + (새로운 물감 * strength)
                    // 새로운 W = (이전 W * (1-strength)) + (새로운 물 * strength * 0.5)
                    // 단순화: 그냥 강한 값으로 덮어씀 (C는 RGB값 사용, W는 고정값)
                    finalC = clamp(current_values.x + strength * 0.3, 0.0, 1.0); // pressure increases pigment deposit
                    finalW = clamp(current_values.y + strength * 0.6, 0.0, 1.0); // water added scaled by pressure
                }

                textureStore(outputSim, coord, vec4<f32>(finalC, finalW, 0.0, 1.0));
            }
        `;

        // 최종 렌더링 셰이더
        const renderShaderWGSL = `
            @group(0) @binding(0) var simTexture: texture_2d<f32>; // 시뮬레이션 결과 텍스처
            @group(0) @binding(1) var simSampler: sampler;         // 샘플러
            @group(0) @binding(2) var<uniform> currentColor: vec4<f32>; // 선택된 RGB 색상

            struct VertexOutput {
                @builtin(position) position: vec4<f32>,
                @location(0) texCoord: vec2<f32>,
            };

            @vertex
            fn vertex_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
                var output: VertexOutput;
                let pos = array<vec2<f32>, 6>(
                    vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), 
                    vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0)
                );
                let tex = array<vec2<f32>, 6>(
                    vec2(0.0, 1.0), vec2(1.0, 1.0), vec2(0.0, 0.0), 
                    vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(1.0, 0.0)
                );
                
                output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                output.texCoord = tex[vertexIndex];
                return output;
            }

            @fragment
            fn fragment_main(input: VertexOutput) -> @location(0) vec4<f32> {
                let simValue = textureSample(simTexture, simSampler, input.texCoord).xy;
                let C = simValue.x; // 물감 농도
                let W = simValue.y; // 물/습도

                // 물감 농도 C를 사용하여 색상을 조정
                // C가 0이면 흰색, C가 1에 가까우면 선택된 색상으로
                // W(습도)는 번짐의 투명도를 조절하는 데 사용될 수 있지만, 여기서는 C에 집중.
                
                // 수채화처럼 옅게 보이지만 농도에 따라 진해지게
                let finalR = mix(1.0, currentColor.r, C * 0.7); // 0.7은 색상의 최대 진하기 (조절 가능)
                let finalG = mix(1.0, currentColor.g, C * 0.7);
                let finalB = mix(1.0, currentColor.b, C * 0.7);

                // 물감 가장자리가 살짝 어두워지는 효과 (안료 응집)
                let edgeEffect = smoothstep(0.0, 0.2, C) * (1.0 - smoothstep(0.8, 1.0, C));
                let darkEdge = vec3<f32>(0.0, 0.0, 0.0) * edgeEffect * 0.1; // 가장자리에 어두운 색상 추가
                
                return vec4<f32>(vec3(finalR, finalG, finalB) + darkEdge, 1.0);
            }
        `;

        // ===== Utility Functions =====

        // 헥사 코드를 RGBA 포맷으로 변환
        function hexToRgbaArray(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255.0;
            const g = parseInt(hex.slice(3, 5), 16) / 255.0;
            const b = parseInt(hex.slice(5, 7), 16) / 255.0;
            return [r, g, b, 1.0];
        }

        // ===== WebGPU Initialization =====
        async function initWebGPU() {
            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter) {
                alert("WebGPU 어댑터를 찾을 수 없습니다.");
                return;
            }
            const device = await adapter.requestDevice();
            
            const canvas = document.getElementById('webgpuCanvas');
            const context = canvas.getContext('webgpu');

            const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: presentationFormat,
                alphaMode: 'opaque', // 캔버스 배경이 흰색이므로 opaque (불투명)
            });

            // ===== Simulation Textures (Double Buffering) =====
            const simTextureFormat = 'rgba32float'; // C, W, (padding), (padding)
            let inputSimTexture = device.createTexture({
                size: [SIM_SIZE, SIM_SIZE],
                format: simTextureFormat,
                // 이 텍스처는 셰이더에서 읽기/쓰기(STORAGE_BINDING)와 샘플링(TEXTURE_BINDING)
                // 초기화나 clear에 사용할 수 있도록 COPY_DST도 허용해야 writeTexture를 사용할 수 있습니다.
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST,
            });
            let outputSimTexture = device.createTexture({
                size: [SIM_SIZE, SIM_SIZE],
                format: simTextureFormat,
                // output 텍스처 또한 GPU에서 쓰고(copy로 초기화) 셰이더에서 읽고 쓸 수 있어야 합니다.
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST,
            });

            // 텍스처 뷰 (바인드 그룹에 사용)
            let inputSimView = inputSimTexture.createView();
            let outputSimView = outputSimTexture.createView();

            // 시뮬레이션 초기화 (모든 픽셀을 W=1.0, C=0.0으로)
            const initialData = new Float32Array(SIM_SIZE * SIM_SIZE * 4); // RGBA
            for (let i = 0; i < SIM_SIZE * SIM_SIZE; i++) {
                initialData[i * 4 + 0] = 0.0; // C (물감 농도)
                initialData[i * 4 + 1] = 1.0; // W (물/습도)
                initialData[i * 4 + 2] = 0.0; // R
                initialData[i * 4 + 3] = 1.0; // G
            }
            device.queue.writeTexture(
                { texture: inputSimTexture },
                initialData,
                { bytesPerRow: SIM_SIZE * 4 * 4 }, // 4 bytes per float, 4 channels
                { width: SIM_SIZE, height: SIM_SIZE }
            );


            // ===== Uniform Buffers =====
            // Simulation Params Uniform Buffer
            const simParamsBufferSize = (5 * Float32Array.BYTES_PER_ELEMENT); // dc, dw, dt, feed, kill
            const simParamsBuffer = device.createBuffer({
                size: simParamsBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const simParamsData = new Float32Array([
                0.015,  // diffusionRateC (물감 확산 속도, 낮을수록 뭉침)
                0.005,  // diffusionRateW (물 확산 속도, 높을수록 번짐)
                1.0,    // timeStep
                0.02,   // feedRate (새 물감 주입 속도)
                0.05    // killRate (물 증발/소모 속도)
            ]);
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData);

            // Input Params Uniform Buffer (마우스 입력)
            const inputParamsBufferSize = (7 * Float32Array.BYTES_PER_ELEMENT); // x, y, radius, r, g, b, pressure
            const inputParamsBuffer = device.createBuffer({
                size: inputParamsBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const inputParamsData = new Float32Array([0, 0, 0.025, 1, 0, 0, 1.0]); // 초기값: x,y,radius, r,g,b, pressure
            device.queue.writeBuffer(inputParamsBuffer, 0, inputParamsData);

            // Current Color Uniform Buffer (렌더링)
            const currentColorBufferSize = (4 * Float32Array.BYTES_PER_ELEMENT); // r, g, b, a
            const currentColorBuffer = device.createBuffer({
                size: currentColorBufferSize,
                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            });
            const currentColorData = hexToRgbaArray('#9E1111'); // 초기 색상 (JS 배열)
            // writeBuffer는 ArrayBuffer/TypedArray를 기대하므로 Float32Array로 전달합니다.
            device.queue.writeBuffer(currentColorBuffer, 0, new Float32Array(currentColorData));


            // ===== Compute Pipelines =====
            // Simulation Compute Pipeline
            const simPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: device.createShaderModule({ code: simulationShaderWGSL }),
                    entryPoint: 'main',
                },
            });

            // Input Compute Pipeline (마우스 드로잉)
            const inputPipeline = device.createComputePipeline({
                layout: 'auto',
                compute: {
                    module: device.createShaderModule({ code: inputShaderWGSL }),
                    entryPoint: 'main',
                },
            });

            // ===== Render Pipeline =====
            // Full-screen Quad Vertex Buffer (for rendering)
            const vertices = new Float32Array([
                -1.0, -1.0,  0.0, 1.0, // pos, texCoord
                 1.0, -1.0,  1.0, 1.0,
                -1.0,  1.0,  0.0, 0.0,

                -1.0,  1.0,  0.0, 0.0,
                 1.0, -1.0,  1.0, 1.0,
                 1.0,  1.0,  1.0, 0.0,
            ]);
            const vertexBuffer = device.createBuffer({
                size: vertices.byteLength,
                usage: GPUBufferUsage.VERTEX,
                mappedAtCreation: true,
            });
            new Float32Array(vertexBuffer.getMappedRange()).set(vertices);
            vertexBuffer.unmap();

            // Sampler for Render Pipeline
            const simSampler = device.createSampler({
                magFilter: 'linear',
                minFilter: 'linear',
            });

            const renderPipeline = device.createRenderPipeline({
                layout: 'auto',
                vertex: {
                    module: device.createShaderModule({ code: renderShaderWGSL }),
                    entryPoint: 'vertex_main',
                    buffers: [{
                        arrayStride: 4 * Float32Array.BYTES_PER_ELEMENT, // 4 floats (x,y,u,v)
                        attributes: [
                            { shaderLocation: 0, offset: 0, format: 'float32x2' }, // Position
                            { shaderLocation: 1, offset: 2 * Float32Array.BYTES_PER_ELEMENT, format: 'float32x2' }, // TexCoord
                        ],
                    }],
                },
                fragment: {
                    module: device.createShaderModule({ code: renderShaderWGSL }),
                    entryPoint: 'fragment_main',
                    targets: [{ format: presentationFormat }],
                },
                primitive: {
                    topology: 'triangle-list',
                },
            });

            // ===== Bind Groups =====
            // Simulation Bind Group (updates every frame for double buffering)
            let simBindGroup = device.createBindGroup({
                layout: simPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: simParamsBuffer } },
                    { binding: 1, resource: inputSimView },
                    { binding: 2, resource: outputSimView },
                ],
            });

            // Input Bind Group (updates for mouse input)
            let inputBindGroup = device.createBindGroup({
                layout: inputPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: inputParamsBuffer } },
                    { binding: 1, resource: inputSimView },
                    { binding: 2, resource: outputSimView },
                ],
            });

            // Render Bind Group (reads final simulation texture)
            let renderBindGroup = device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: inputSimView },
                    { binding: 1, resource: simSampler },
                    { binding: 2, resource: { buffer: currentColorBuffer } },
                ],
            });
            

            // ===== Animation Loop =====
            let isDrawing = false;
            let currentBrushRadius = 0.025; // 캔버스 너비 대비 비율 (초기값) (halved)
            const MAX_BRUSH_RADIUS = 0.15; // 최대 브러시 크기 (캔버스 너비 대비)
            const BRUSH_GROW_SPEED = 0.0002; // 마우스 누르는 동안 브러시 커지는 속도

            function frame() {
                // Resize canvas if needed
                if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    // WebGPU context reconfigure if size changes (optional for fixed size sim)
                    context.configure({
                        device,
                        format: presentationFormat,
                        alphaMode: 'opaque',
                        size: [canvas.width, canvas.height]
                    });
                }

                // 1. Compute Simulation
                const commandEncoder = device.createCommandEncoder();
                const computePass = commandEncoder.beginComputePass();

                // Swap textures for simulation
                simBindGroup = device.createBindGroup({
                    layout: simPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: simParamsBuffer } },
                        { binding: 1, resource: inputSimView },
                        { binding: 2, resource: outputSimView },
                    ],
                });

                computePass.setPipeline(simPipeline);
                computePass.setBindGroup(0, simBindGroup);
                computePass.dispatchWorkgroups(SIM_SIZE / WORKGROUP_SIZE, SIM_SIZE / WORKGROUP_SIZE);
                computePass.end();

                // 2. Swap input/output textures
                [inputSimTexture, outputSimTexture] = [outputSimTexture, inputSimTexture];
                inputSimView = inputSimTexture.createView();
                outputSimView = outputSimTexture.createView();

                // 3. Render final simulation texture to canvas
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: context.getCurrentTexture().createView(),
                        loadOp: 'clear',
                        clearValue: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },
                        storeOp: 'store',
                    }],
                });

                // Update render bind group with new inputSimView (which now holds latest sim state)
                renderBindGroup = device.createBindGroup({
                    layout: renderPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: inputSimView }, // Render latest sim state
                        { binding: 1, resource: simSampler },
                        { binding: 2, resource: { buffer: currentColorBuffer } },
                    ],
                });

                renderPass.setPipeline(renderPipeline);
                renderPass.setBindGroup(0, renderBindGroup);
                renderPass.setVertexBuffer(0, vertexBuffer);
                renderPass.draw(6);
                renderPass.end();

                device.queue.submit([commandEncoder.finish()]);

                requestAnimationFrame(frame);
            }

            // ===== Event Listeners =====
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                currentBrushRadius = 0.025; // 클릭 시 초기 브러시 크기 (halved to match overlay)
                handleMouseMove(e); // 첫 클릭 위치에 바로 그리기
            });

            // pointer events for stylus/touch
            canvas.addEventListener('pointerdown', (e) => {
                isDrawing = true;
                currentBrushRadius = 0.025;
                try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
                handleMouseMove(e);
            });

            document.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            document.addEventListener('pointerup', () => { isDrawing = false; });

            canvas.addEventListener('mousemove', handleMouseMove);

            function handleMouseMove(e, force = false) {
                if (!isDrawing && !force) return;

                // 브러시 크기 성장
                currentBrushRadius = Math.min(currentBrushRadius + BRUSH_GROW_SPEED, MAX_BRUSH_RADIUS);

                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left) / rect.width;  // 0.0 to 1.0
                const mouseY = (e.clientY - rect.top) / rect.height; // 0.0 to 1.0

                // Update Input Params Buffer
                // Use the currently selected color from the top-level UI if available
                const selectedHex = window.currentDrawColorGlobal || '#9E1111';
                const rgb = hexToRgbaArray(selectedHex);
                const pressureVal = (typeof e.pressure === 'number' && e.pressure > 0) ? e.pressure : 1.0;
                const inputParamsUpdatedData = new Float32Array([
                    mouseX, mouseY, currentBrushRadius,
                    rgb[0], rgb[1], rgb[2], pressureVal
                ]);
                device.queue.writeBuffer(inputParamsBuffer, 0, inputParamsUpdatedData);

                // Compute Input (draw on current inputSimTexture)
                const inputEncoder = device.createCommandEncoder();
                const inputPass = inputEncoder.beginComputePass();

                // Swap input/output textures for the input pass
                inputBindGroup = device.createBindGroup({
                    layout: inputPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: inputParamsBuffer } },
                        { binding: 1, resource: inputSimView },
                        { binding: 2, resource: outputSimView },
                    ],
                });

                inputPass.setPipeline(inputPipeline);
                inputPass.setBindGroup(0, inputBindGroup);
                inputPass.dispatchWorkgroups(SIM_SIZE / WORKGROUP_SIZE, SIM_SIZE / WORKGROUP_SIZE);
                inputPass.end();
                device.queue.submit([inputEncoder.finish()]);

                // Swap after input pass to make the newly drawn input the next 'input' for simulation
                [inputSimTexture, outputSimTexture] = [outputSimTexture, inputSimTexture];
                inputSimView = inputSimTexture.createView();
                outputSimView = outputSimTexture.createView();
            }


            // Expose GPU objects to top-level UI (so color selection / clear work when GPU is ready)
            deviceGlobal = device;
            currentColorBufferGlobal = currentColorBuffer;
            inputParamsBufferGlobal = inputParamsBuffer;
            inputSimTextureGlobal = inputSimTexture;
            outputSimTextureGlobal = outputSimTexture;
            initialDataGlobal = initialData;

            // Allow top-level UI to call into GPU draw handler
            window.performGpuInput = function(e) {
                try { handleMouseMove(e, true); } catch (err) { /* ignore if handler not ready */ }
            };

            // Ensure the GPU uniform buffer is in-sync with any color already selected by the UI
            if (window.currentDrawColorGlobal) {
                try {
                    device.queue.writeBuffer(currentColorBuffer, 0, new Float32Array(hexToRgbaArray(window.currentDrawColorGlobal)));
                } catch (err) { /* non-fatal */ }
            }

            // Start the frame loop
            requestAnimationFrame(frame);

        }

        // Call init and report any errors gracefully
        initWebGPU().catch(err => {
            console.error('WebGPU 초기화 실패:', err);
            alert('WebGPU 초기화에 실패했습니다. 콘솔을 확인하세요.');
        });
    </script>
</body>
</html>