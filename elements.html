<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ELEMENTAL GLOW</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #f9f9f9;
      display: flex;
      align-items: center;
    }

      .carousel-wrap {
        position: relative;
        width: 100%;
        max-width: 1800px;
        height: 600px;
        display: flex;
        align-items: center;
        justify-content: center;
        perspective: 1000px;
        overflow: hidden;
      }

      .container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 48px;
        transition: transform 0.6s cubic-bezier(.22,.9,.28,1);
        will-change: transform;
        padding: 40px 0;
      }

     .card {
      /* use fixed base size and animate with transforms (no width/height transitions)
        to avoid layout reflow and jitter during animation */
      width: 220px; /* base (side) width */
      height: 300px; /* base (side) height */
      margin: 0 20px;
      border-radius: 16px;
      box-shadow: 0 6px 14px rgba(0,0,0,0.22);
      transition: transform 0.45s cubic-bezier(.22,.9,.28,1), opacity 0.45s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #fff;
      user-select: none;
      font-size: 24px;
      cursor: pointer;
      flex-shrink: 0;
      perspective: 1000px;
      overflow: hidden;
    }

    /* flip inner */
    .card-inner {
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      position: relative;
      border-radius: 16px;
    }

    .card-front, .card-back {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 16px;
      backface-visibility: hidden;
      overflow: hidden;
    }

    /* 앞면에 이미지를 넣을 수 있도록 구조 설정 */
    .card-front {
      /* show only the image — make the front transparent so no white box appears */
      background: transparent;
      position: relative;
      overflow: hidden;
    }

    .card-front .card-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      /* match card rounded corners so only image is visible within radius */
      border-radius: inherit;
      pointer-events: auto; /* images are clickable */
    }

    /* card-label removed — front images no longer show a number overlay */

    /* 카드 뒷면 배경색은 아래 .card-back 규칙을 변경하세요 (또는 --card-back-bg 변수 사용)
       위치: 이 파일에서 `.card-back` 규칙의 `background` 속성을 수정하면 됩니다. */
    .card-back {
      background: var(--card-back-bg, #666);
      color: #fff;
      transform: rotateY(180deg);
      font-size: 18px;
      padding: 8px;
      box-sizing: border-box;
      /* place content from top to bottom so the title sits at the top */
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: stretch;
    }

    /* 회전(빙글) 애니메이션: 정방향(앞->뒤) */
    @keyframes spinFlip {
      from { transform: rotateY(0deg); }
      to   { transform: rotateY(180deg); }
    }

    /* 역방향(뒤->앞) */
    @keyframes spinBack {
      from { transform: rotateY(180deg); }
      to   { transform: rotateY(0deg); }
    }

    .card-inner.spinning { animation: spinFlip 0.7s cubic-bezier(.22,.9,.28,1) forwards; }
    .card-inner.spinning-back { animation: spinBack 0.7s cubic-bezier(.22,.9,.28,1) forwards; }
    /* persistent flipped state: when a card has the 'flipped' marker keep it rotated */
    .card-inner.flipped { transform: rotateY(180deg); }

    /* pager removed per design — top-center dot indicator disabled */
    .card.center {
      z-index: 30;
      opacity: 1;
      transform: scale(1.5); /* 중앙 카드 크기 조정 */
    }

    .card.side {
      z-index: 20;
      opacity: 0.9;
      transform: scale(1.0);
    }

    .card.end {
      z-index: 10;
      opacity: 0.5;
        transform: scale(0.75);
      margin: 0 3px; /* outermost ends narrowed to 3px */
    }

    .card.off {
      opacity: 0;
      transform: scale(0.6);
      pointer-events: none;
      margin: 0 3px; /* outermost off-cards narrowed to 3px */
    }

    .dots {
      position: absolute;
      top: 80px;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 10px;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #999;
      transition: background 0.3s;
    }

    .dot.active {
      background: #333;
    }

    .home-btn {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      color: #444;
      cursor: pointer;
      text-decoration: underline;
    }

    .next-page-btn {
      position: absolute;
      /* shifted slightly higher */
      bottom: 48px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      background: #000;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      /* only transition colors (no movement animation) */
      transition: background-color 0.18s ease, color 0.18s ease;
      z-index: 50;
    }

    /* hover: change to achromatic (neutral gray background + dark text) */
    .next-page-btn:hover {
      background-color: #efefef; /* very light gray */
      color: #222; /* dark neutral text */
    }

    .next-page-btn:active {
      /* slightly darker gray when pressed */
      background-color: #e0e0e0;
      color: #111;
    }

    /* top explanatory text about flame reaction */
    .top-intro {
      position: absolute;
      /* push the intro down by 50px */
      top: 68px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 980px;
      text-align: center;
      z-index: 70;
      color: #222;
      font-family: 'Noto Sans KR', system-ui, sans-serif;
      pointer-events: none; /* informational only */
    }

    /* wrapper that looks like a neat floating info card */
    .top-intro .intro-box {
      display: inline-block;
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.06);
      padding: 14px 20px;
      border-radius: 14px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.07);
      backdrop-filter: blur(4px);
      text-align: left;
      max-width: 880px;
    }

    .top-intro h2 { margin: 0 0 6px 0; font-size: 20px; font-weight: 700; }
    .top-intro p { margin: 0; font-size: 14px; color: #444; line-height: 1.45; max-width: 880px; }

    /* small label shown at the top of the card back faces */
    .card-back-title {
      width: 100%;
      padding: 8px 10px;
      box-sizing: border-box;
      font-size: 13px;
      font-weight: 700;
      text-align: center;
      color: rgba(255,255,255,0.95);
      opacity: 0.95;
      border-bottom: 1px solid rgba(255,255,255,0.06);
    }
  </style>
</head>
<body>
  <div class="dots" id="dots"></div>
  <!-- introductory explanation text -->
  <div class="top-intro" aria-hidden="false">
    <div class="intro-box">
      <h2>불꽃 반응이란?</h2>
      <p>
        물질을 불꽃에 닿게 했을 때, 원소 안의 전자가 높은 에너지 상태로 올라갔다가 다시 내려오며 고유한 빛을 방출하는 현상이다.<br>
        이때 나타나는 불꽃의 색은 각 원소가 가진 고유한 파장에 따라 달라진다.<br>
        따라서 불꽃의 색을 통해 어떤 원소가 포함되어 있는지 구별할 수 있다.
      </p>
    </div>
  </div>
  <!-- pager removed per design -->
  <button class="next-page-btn" id="nextPageBtn">시뮬레이션 해보기</button>

  <div class="carousel-wrap">
    <div class="container" id="carousel"></div>
  </div>

  <script>
    const TOTAL = 18;
    // ------------------------------------------------------------------
    // 카드 앞면 이미지 및 뒷면 색상 설정
    // - 앞면 이미지는 이 파일과 같은 폴더에 `card1.png` ~ `card18.png` 로 배치하세요.
    // - 뒷면 색상(헥사코드)은 아래 BACK_COLORS 배열을 수정하세요.
    //   변경하려면 이 파일에서 `BACK_COLORS` 배열의 값을 원하는 hex로 바꾸면 됩니다.
    // ------------------------------------------------------------------
    const BACK_COLORS = [
      '#9E1111', '#CD0000', '#E25600', '#C8753A','#E5B20A', '#9CA663', '#7E873A',
      '#28AF41', '#00DE6F', '#009D6B', '#649C99', '#00C9D0', '#1389B4',
      '#0A77BA', '#3D6798', '#B39BBE', '#8C5368', '#7B2626'
    ];
    // per-card back labels -- edit these to change each card's back header text
    const BACK_TEXTS = [
          'Li', 'Sr', 'Fe', 'Sc',
      'Na', 'Mn', 'Mo', 'B',
      'Cu', 'Nb', 'Cd', 'Rb',
      'K', 'Se', 'S', 'As',
      'Zn', 'P'
    ];
    const container = document.getElementById('carousel');
    const dotsContainer = document.getElementById('dots');

    // create cards dynamically with numbers and tag real indices (use inner front/back for flip)
    for (let i = 0; i < TOTAL; i++) {
      const c = document.createElement('div');
      c.className = 'card';
      const backText = BACK_TEXTS[i] || '텍스트가 들어갈곳';
      c.innerHTML = `
        <div class="card-inner">
          <div class="card-front">
            <img class="card-img" src="./card${i + 1}.png" alt="Card ${i + 1}">
          </div>
          <div class="card-back"><div class="card-back-title">${backText}</div></div>
        </div>
      `;
      // apply back color via CSS variable so .card-back uses it
      const backColor = BACK_COLORS[i % BACK_COLORS.length] || '#666';
      c.style.setProperty('--card-back-bg', backColor);
      c.style.fontSize = '24px';
      c.style.color = '#fff';
      // mark as original (not clone) and store real index
      c.dataset.clone = 'false';
      c.dataset.realIndex = String(i);
      container.appendChild(c);
    }

    // insert clones: last card before first, first card after last
    // this creates a visual circular loop while we keep logical indexing via data-real-index
    const originalCards = Array.from(container.querySelectorAll('.card'));
    if (originalCards.length >= 2) {
      const first = originalCards[0];
      const last = originalCards[originalCards.length - 1];

      const cloneLast = last.cloneNode(true);
      cloneLast.dataset.clone = 'true';
      // ensure clone has same real index as the original it represents
      cloneLast.dataset.realIndex = last.dataset.realIndex;
      container.insertBefore(cloneLast, first);

      const cloneFirst = first.cloneNode(true);
      cloneFirst.dataset.clone = 'true';
      cloneFirst.dataset.realIndex = first.dataset.realIndex;
      container.appendChild(cloneFirst);
    }

    // re-query cards (includes clones) and bind click handlers referencing the logical real index
    const cards = Array.from(document.querySelectorAll('.card'));

    // allow clicking a visible card (including clones):
    // - if it's the current center -> toggle flip (front <-> back)
    // - otherwise -> center that card (and clear flips from previous center)
    cards.forEach((card) => {
      card.addEventListener('click', (e) => {
        if (card.classList.contains('off')) return;
        const real = parseInt(card.dataset.realIndex, 10);
        const inner = card.querySelector('.card-inner');
        // If click target is the front image:
        // - allow flip only if this card is currently centered
        // - otherwise center the clicked card (do not flip)
        const imgClicked = e.target.closest && e.target.closest('.card-img');
        if (imgClicked) {
          if (card.classList.contains('center')) {
            if (inner) toggleFlip(inner);
            return; // already center and handled flip
          } else {
            // center the clicked card when its image is clicked
            const prevCenter = document.querySelector('.card.center .card-inner');
            if (prevCenter) prevCenter.classList.remove('spinning','spinning-back','flipped');
            index = real;
            updateCards();
            return;
          }
        }
        if (real === index) {
          // toggle flip only on center card (use animated spin)
          if (inner) toggleFlip(inner);
          return;
        }
        // moving to a different card: clear any in-progress spin animations and clear flipped state
        const prevCenter = document.querySelector('.card.center .card-inner');
        if (prevCenter) prevCenter.classList.remove('spinning','spinning-back','flipped');
        index = real;
        updateCards();
      });
    });

    let index = 0; // start at card 0 (which displays as "1")
    let baseOffset = 0;
    let isFirstLayout = true;

    function getCurrentTranslateX(el) {
      const st = window.getComputedStyle(el);
      const tr = st.transform || st.webkitTransform || st.mozTransform;
      if (!tr || tr === 'none') return 0;
      const m = tr.match(/matrix\((.+)\)/);
      if (m) {
        const values = m[1].split(',');
        return parseFloat(values[4]);
      }
      const m3 = tr.match(/matrix3d\((.+)\)/);
      if (m3) {
        const values = m3[1].split(',');
        return parseFloat(values[12]);
      }
      return 0;
    }

    function updateCards() {
      // assign classes based on wrapped distance using logical real indices
      cards.forEach((card) => {
        card.classList.remove('center', 'side', 'end', 'off');
        const real = parseInt(card.dataset.realIndex, 10);

        let d = real - index;
        if (d > TOTAL / 2) d -= TOTAL;
        if (d < -TOTAL / 2) d += TOTAL;
        d = Math.abs(d);

        if (d === 0) card.classList.add('center');
        else if (d === 1) card.classList.add('side');
        else if (d === 2) card.classList.add('end');
        else card.classList.add('off');
      });

      // ensure flipped cards are only allowed when center; remove flips when cards are not center
      cards.forEach(card => {
        if (!card.classList.contains('center')) {
          const inner = card.querySelector('.card-inner');
          if (inner) inner.classList.remove('flipped','spinning','spinning-back');
        }
      });

      // Re-center container so the real active (original) card sits exactly in the wrap center
      // prefer the original (non-clone) element for centering
      let activeCard = document.querySelector(`.card[data-real-index="${index}"]:not([data-clone="true"])`);
      if (!activeCard) activeCard = document.querySelector(`.card[data-real-index="${index}"]`);
      if (!activeCard) return;

      const wrapRect = document.querySelector('.carousel-wrap').getBoundingClientRect();
      const cardRect = activeCard.getBoundingClientRect();

      // how far the card center is from wrap center (positive = card is to the right)
      const cardCenter = cardRect.left + cardRect.width / 2;
      const wrapCenter = wrapRect.left + wrapRect.width / 2;
      const delta = cardCenter - wrapCenter;

      // compute new translate based on current transform to avoid absolute reflow jumps
      const currentTx = getCurrentTranslateX(container);
      const newTx = currentTx - delta;

      // keep subpixel precision but round to 0.5 to reduce repaints; use translate3d for GPU
      const rounded = Math.round(newTx * 2) / 2;
      container.style.transform = `translate3d(${rounded}px,0,0)`;

      // pager removed — no top-center indicator
    }



    // Toggle flip with animated spin: plays forward/back animations and sets 'flipped' state
    function toggleFlip(inner) {
      if (!inner) return;
      if (inner._animating) return; // prevent double-trigger
      if (inner.classList.contains('flipped')) {
        // currently flipped -> animate back to front (reverse animation)
        inner._animating = true;
        inner.classList.remove('spinning');
        inner.classList.add('spinning-back');
            const onEndBack = function () {
            inner.classList.remove('spinning-back','flipped');
            inner._animating = false;
            inner.removeEventListener('animationend', onEndBack);
            // pager removed — no update needed
        };
        inner.addEventListener('animationend', onEndBack);
        return;
      } else {
        inner._animating = true;
        inner.classList.remove('spinning-back');
        inner.classList.add('spinning');
            const onEnd = function () {
          inner.classList.remove('spinning');
          inner.classList.add('flipped');
          inner._animating = false;
          inner.removeEventListener('animationend', onEnd);
            // pager removed — no update needed
        };
        inner.addEventListener('animationend', onEnd);
      }
    }

    function nextCard() {
      index = (index + 1) % TOTAL;
      updateCards();
    }

    function prevCard() {
      index = (index - 1 + TOTAL) % TOTAL;
      updateCards();
    }

    // wheel -> slide with brief throttle
    let wheelLock = false;
    window.addEventListener('wheel', e => {
      if (wheelLock) return;
      wheelLock = true;
      if (e.deltaY > 0) nextCard();
      else prevCard();
      setTimeout(() => { wheelLock = false; }, 350);
    }, {passive: true});

    // mouse drag/swipe support
    let dragStart = null;
    let dragLock = false;
    const DRAG_THRESHOLD = 50;

    document.addEventListener('mousedown', e => {
      dragStart = e.clientX;
      dragLock = false;
    });

    document.addEventListener('mousemove', e => {
      if (!dragStart || dragLock) return;
      const dragDist = dragStart - e.clientX;
      if (Math.abs(dragDist) > DRAG_THRESHOLD) {
        dragLock = true;
        if (dragDist > 0) nextCard();
        else prevCard();
        dragStart = null;
      }
    });

    document.addEventListener('mouseup', () => {
      dragStart = null;
    });

    // When transition finishes, snap to a half-pixel aligned translate to reduce sub-pixel jitter
    container.addEventListener('transitionend', (e) => {
      if (e.propertyName !== 'transform') return;
      // prefer the original (non-clone) element for centering calculations
      let activeCard = document.querySelector(`.card[data-real-index="${index}"]:not([data-clone="true"])`);
      if (!activeCard) activeCard = document.querySelector(`.card[data-real-index="${index}"]`);
      if (!activeCard) return;
      const wrapRect = document.querySelector('.carousel-wrap').getBoundingClientRect();
      const cardRect = activeCard.getBoundingClientRect();
      const cardCenter = cardRect.left + cardRect.width / 2;
      const wrapCenter = wrapRect.left + wrapRect.width / 2;
      const delta = cardCenter - wrapCenter;

      const currentTx = getCurrentTranslateX(container);
      const snapped = Math.round((currentTx - delta) * 2) / 2; // half-pixel snap
      // set snapped transform but keep transition intact (no toggling)
      container.style.transform = `translate3d(${snapped}px,0,0)`;
    });

    // initial layout
    // pager feature removed
    requestAnimationFrame(() => updateCards());

    // Next page button handler
    document.getElementById('nextPageBtn').addEventListener('click', () => {
      window.location.href = 'simulation.html';
    });
  </script>
</body>
</html>
